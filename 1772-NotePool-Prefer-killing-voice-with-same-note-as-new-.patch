From ec965db9e3b7ae3e3a8ce3b80440f585da41c872 Mon Sep 17 00:00:00 2001
From: Ricard Wanderlof <polluxsynth@butoba.net>
Date: Sat, 18 Sep 2021 22:37:52 +0200
Subject: [PATCH 1772/1936] NotePool: Prefer killing voice with same note as
 new (#303)

When killing a voice due to Pvoicelimit being reached, prefer
to kill a voice which has the same note as the new one being
played, the rationale being that it will cause the least disruption
to the sonic image, compared to yanking another note, whose
absence is more likely to be noticed.
---
 src/Containers/NotePool.cpp | 52 ++++++++++++++++++++++++++++++-------
 src/Containers/NotePool.h   |  3 ++-
 src/Misc/Part.cpp           | 10 +++----
 src/Misc/Part.h             |  2 +-
 4 files changed, 50 insertions(+), 17 deletions(-)

diff --git a/src/Containers/NotePool.cpp b/src/Containers/NotePool.cpp
index 7e38642b..c18d9f61 100644
--- a/src/Containers/NotePool.cpp
+++ b/src/Containers/NotePool.cpp
@@ -349,50 +349,73 @@ int NotePool::getRunningVoices(void) const
     return running_count;
 }
 
-void NotePool::enforceVoiceLimit(int limit)
+// Silence one voice, trying to the select the one that will be the least
+// intrusive, preferably preferred_note if possible..
+void NotePool::limitVoice(int preferred_note)
 {
-    int notes_to_kill = getRunningVoices() - limit;
-    if(notes_to_kill <= 0)
-        return;
-
-    // TODO: Loop the rest of the function once for each notes_to_kill.
-    // However, normally we are called once per new note played, so
-    // notes_to_kill will be at most one.
-
     NoteDescriptor *oldest_released = NULL;
+    NoteDescriptor *oldest_released_samenote = NULL;
     NoteDescriptor *oldest_sustained = NULL;
+    NoteDescriptor *oldest_sustained_samenote = NULL;
     NoteDescriptor *oldest_latched = NULL;
+    NoteDescriptor *oldest_latched_samenote = NULL;
     NoteDescriptor *oldest_playing = NULL;
+    NoteDescriptor *oldest_playing_samenote = NULL;
+
     for(auto &nd : activeDesc()) {
         // printf("Scanning %d (%s (%d), age %u)\n", nd.note, getStatus(nd.status), nd.status, nd.age);
         if (nd.released()) {
             if (!oldest_released || nd.age > oldest_released->age)
                 oldest_released = &nd;
+            if (nd.note == preferred_note &&
+                (!oldest_released_samenote || oldest_released_samenote->age))
+                oldest_released_samenote = &nd;
         } else if (nd.sustained()) {
             if (!oldest_sustained || nd.age > oldest_sustained->age)
                 oldest_sustained = &nd;
+            if (nd.note == preferred_note &&
+                (!oldest_sustained_samenote || oldest_sustained_samenote->age))
+                oldest_sustained_samenote = &nd;
         } else if (nd.latched()) {
             if (!oldest_latched || nd.age > oldest_latched->age)
                 oldest_latched = &nd;
+            if (nd.note == preferred_note &&
+                (!oldest_latched_samenote || oldest_latched_samenote->age))
+                oldest_latched_samenote = &nd;
         } else if (nd.playing()) {
             if (!oldest_playing || nd.age > oldest_playing->age)
                 oldest_playing = &nd;
+            if (nd.note == preferred_note &&
+                (!oldest_playing_samenote || oldest_playing_samenote->age))
+                oldest_playing_samenote = &nd;
         }
     }
 
     // Prioritize which note to kill: if a released note exists, take that,
     // otherwise sustained, latched or playing, in that order.
+    // Within each category, favour a voice that is already playing the
+    // same note, which minimizes stealing notes that are still playing
+    // something significant, especially when there are a lot of repeated
+    // notes being played.
     // If we don't have anything to kill, there's a logical error somewhere,
     // but we can't do anything about it here so just silently return.
 
     NoteDescriptor *to_kill = NULL;
 
-    if (oldest_released)
+    if (oldest_released_samenote)
+        to_kill = oldest_released_samenote;
+    else if (oldest_released)
         to_kill = oldest_released;
+    else if (oldest_sustained_samenote)
+        to_kill = oldest_sustained_samenote;
     else if (oldest_sustained)
         to_kill = oldest_sustained;
+    else if (oldest_latched_samenote)
+        to_kill = oldest_latched_samenote;
     else if (oldest_latched)
         to_kill = oldest_latched;
+    else if (oldest_playing_samenote)
+        to_kill = oldest_playing_samenote;
     else if (oldest_playing)
         to_kill = oldest_playing;
 
@@ -402,6 +425,15 @@ void NotePool::enforceVoiceLimit(int limit)
     }
 }
 
+void NotePool::enforceVoiceLimit(int limit, int preferred_note)
+{
+    int notes_to_kill = getRunningVoices() - limit;
+
+    while (notes_to_kill-- > 0)
+	limitVoice(preferred_note);
+}
+
+
 void NotePool::releasePlayingNotes(void)
 {
     for(auto &d:activeDesc()) {
diff --git a/src/Containers/NotePool.h b/src/Containers/NotePool.h
index 1b30281a..c0927d34 100644
--- a/src/Containers/NotePool.h
+++ b/src/Containers/NotePool.h
@@ -139,7 +139,8 @@ class NotePool
         int getRunningNotes(void) const;
         void enforceKeyLimit(int limit);
         int getRunningVoices(void) const;
-        void enforceVoiceLimit(int limit);
+        void enforceVoiceLimit(int limit, int preferred_note);
+        void limitVoice(int preferred_note);
 
         void releasePlayingNotes(void);
         void releaseNote(note_t note);
diff --git a/src/Misc/Part.cpp b/src/Misc/Part.cpp
index e1d57817..3acddccf 100644
--- a/src/Misc/Part.cpp
+++ b/src/Misc/Part.cpp
@@ -585,7 +585,7 @@ bool Part::NoteOnInternal(note_t note,
         const int sendto = Pkitmode ? item.sendto() : 0;
 
         // Enforce voice limit, before we trigger new note
-        limit_voices(true);
+        limit_voices(note);
 
         try {
             if(item.Padenabled)
@@ -893,7 +893,7 @@ void Part::setkeylimit(unsigned char Pkeylimit_)
 /*
  * Enforce voice limit
  */
-void Part::limit_voices(bool account_for_new_note)
+void Part::limit_voices(int new_note)
 {
     int voicelimit = Pvoicelimit;
     if(voicelimit == 0) /* voice limit disabled */
@@ -903,12 +903,12 @@ void Part::limit_voices(bool account_for_new_note)
      * one less note than the limit, so we don't go above the limit when the
      * new note is triggered.
      */
-    if (account_for_new_note)
+    if (new_note >= 0)
         voicelimit--;
 
     int running_voices = notePool.getRunningVoices();
     if(running_voices >= voicelimit)
-        notePool.enforceVoiceLimit(voicelimit);
+        notePool.enforceVoiceLimit(voicelimit, new_note);
 }
 
 /*
@@ -918,7 +918,7 @@ void Part::setvoicelimit(unsigned char Pvoicelimit_)
 {
     Pvoicelimit = Pvoicelimit_;
 
-    limit_voices(false);
+    limit_voices(-1);
 }
 
 /*
diff --git a/src/Misc/Part.h b/src/Misc/Part.h
index 2714fc5c..bc36adda 100644
--- a/src/Misc/Part.h
+++ b/src/Misc/Part.h
@@ -197,7 +197,7 @@ class Part
 
         NotePool notePool;
 
-        void limit_voices(bool account_for_new_note);
+        void limit_voices(int new_note);
 
         bool lastlegatomodevalid; // To keep track of previous legatomodevalid.
 
-- 
2.47.0

