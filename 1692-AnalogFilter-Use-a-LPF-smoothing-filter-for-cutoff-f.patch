From 528e968c5d12a0e1ef590d1604f02ecf265044cf Mon Sep 17 00:00:00 2001
From: Jonathan Moore Liles <j.liles@unix.net>
Date: Sat, 5 Dec 2020 12:13:03 -0800
Subject: [PATCH 1692/1936] AnalogFilter: Use a LPF smoothing filter for cutoff
 frequency changes and apply in 8 sample chunks.

This removes a zipper artifact that was apparent when using keyboard aftertouch
to modulate filter cutoff.  This commit introduces generic
Value_Smoothing_Filter class (taken from Non-DAW), which can be employed
anywhere else in the application that such smoothing may be required.

A smoothing filter cutoff frequency of 10hz was found by ear to be the minimum
required to suppress the zipper effect.

The filter only runs when the cutoff value is being changed, so the
steady-state performance characteristics are unchanged.
---
 src/DSP/AnalogFilter.cpp           | 84 +++++++++++++++++++++---------
 src/DSP/AnalogFilter.h             |  5 ++
 src/DSP/CMakeLists.txt             |  1 +
 src/DSP/Value_Smoothing_Filter.cpp | 65 +++++++++++++++++++++++
 src/DSP/Value_Smoothing_Filter.h   | 47 +++++++++++++++++
 5 files changed, 178 insertions(+), 24 deletions(-)
 create mode 100644 src/DSP/Value_Smoothing_Filter.cpp
 create mode 100644 src/DSP/Value_Smoothing_Filter.h

diff --git a/src/DSP/AnalogFilter.cpp b/src/DSP/AnalogFilter.cpp
index 81adee76..bb117828 100644
--- a/src/DSP/AnalogFilter.cpp
+++ b/src/DSP/AnalogFilter.cpp
@@ -46,6 +46,7 @@ AnalogFilter::AnalogFilter(unsigned char Ftype,
     firsttime  = true;
     coeff.d[0] = 0; //this is not used
     outgain    = 1.0f;
+    freq_smoothing.sample_rate(samplerate_f);
 }
 
 AnalogFilter::~AnalogFilter()
@@ -280,15 +281,6 @@ void AnalogFilter::setfreq(float frequency)
 
     bool nyquistthresh = (abovenq ^ oldabovenq);
 
-
-    //if the frequency is changed fast, it needs interpolation
-    if((rap > 3.0f) || nyquistthresh) { //(now, filter and coefficients backup)
-        oldCoeff = coeff;
-        for(int i = 0; i < MAX_FILTER_STAGES + 1; ++i)
-            oldHistory[i] = history[i];
-        if(!firsttime)
-            needsinterpolation = true;
-    }
     freq = frequency;
     computefiltercoefs();
     firsttime = false;
@@ -383,26 +375,70 @@ void AnalogFilter::singlefilterout(float *smp, fstage &hist,
     }
 }
 
-void AnalogFilter::filterout(float *smp)
+
+void AnalogFilter::singlefilterout_freqbuf(float *smp, fstage &hist,
+                                   float *freqbuf)
 {
-    for(int i = 0; i < stages + 1; ++i)
-        singlefilterout(smp, history[i], coeff);
+    assert((buffersize % 8) == 0);
 
-    if(needsinterpolation) {
-        //Merge Filter at old coeff with new coeff
-        float ismp[buffersize];
-        memcpy(ismp, smp, bufferbytes);
+    for ( int i = 0; i < buffersize; i += 8 )
+    {
+	/* recompute coeffs for each 8 samples */
+	freq = freqbuf[i];
+	computefiltercoefs();
+	
+	if(order == 1) {  //First order filter
+	    for ( int j = 0; j < 8; j++ )
+	    {
+		float y0 = smp[i+j] * coeff.c[0] + hist.x1 * coeff.c[1]
+		    + hist.y1 * coeff.d[1];
+		hist.y1 = y0;
+		hist.x1 = smp[i+j];
+		smp[i+j]  = y0;
+	    }
+	} else if(order == 2) {//Second order filter
+
+	    const float coeff_[5] = {coeff.c[0], coeff.c[1], coeff.c[2],  coeff.d[1], coeff.d[2]};
+	    float work[4]  = {hist.x1, hist.x2, hist.y1, hist.y2};
+	    
+	    AnalogBiquadFilterA(coeff_, smp[i + 0], work);
+	    AnalogBiquadFilterB(coeff_, smp[i + 1], work);
+	    AnalogBiquadFilterA(coeff_, smp[i + 2], work);
+	    AnalogBiquadFilterB(coeff_, smp[i + 3], work);
+	    AnalogBiquadFilterA(coeff_, smp[i + 4], work);
+	    AnalogBiquadFilterB(coeff_, smp[i + 5], work);
+	    AnalogBiquadFilterA(coeff_, smp[i + 6], work);
+	    AnalogBiquadFilterB(coeff_, smp[i + 7], work);
+	    
+	    hist.x1 = work[0];
+	    hist.x2 = work[1];
+	    hist.y1 = work[2];
+	    hist.y2 = work[3];
+	}
+    }
 
-        for(int i = 0; i < stages + 1; ++i)
-            singlefilterout(ismp, oldHistory[i], oldCoeff);
+    freq = freqbuf[buffersize-1];
+    computefiltercoefs();
+}
 
-        for(int i = 0; i < buffersize; ++i) {
-            float x = (float)i / buffersize_f;
-            smp[i] = ismp[i] * (1.0f - x) + smp[i] * x;
-        }
-        needsinterpolation = false;
-    }
+void AnalogFilter::filterout(float *smp)
+{
 
+    float freqbuf[buffersize];
+    
+    if ( freq_smoothing.apply( freqbuf, buffersize, freq ) )
+    {
+	/* in transition, need to do fine grained interpolation */
+	for(int i = 0; i < stages + 1; ++i)
+	    singlefilterout_freqbuf(smp, history[i], freqbuf);
+    }
+    else
+    {
+	/* stable state, just use one coeff */
+	for(int i = 0; i < stages + 1; ++i)
+	    singlefilterout(smp, history[i], coeff);
+    }
+    
     for(int i = 0; i < buffersize; ++i)
         smp[i] *= outgain;
 }
diff --git a/src/DSP/AnalogFilter.h b/src/DSP/AnalogFilter.h
index 73e5f44a..efd895a4 100644
--- a/src/DSP/AnalogFilter.h
+++ b/src/DSP/AnalogFilter.h
@@ -18,6 +18,7 @@
 
 #include "../globals.h"
 #include "Filter.h"
+#include "Value_Smoothing_Filter.h"
 
 namespace zyn {
 
@@ -61,6 +62,7 @@ class AnalogFilter:public Filter
 
         //Apply IIR filter to Samples, with coefficients, and past history
         void singlefilterout(float *smp, fstage &hist, const Coeff &coeff);
+        void singlefilterout_freqbuf(float *smp, fstage &hist, float *freqbuf);
         //Update coeff and order
         void computefiltercoefs(void);
 
@@ -77,6 +79,9 @@ class AnalogFilter:public Filter
         bool abovenq,                 //if the frequency is above the nyquist
              oldabovenq;              //if the last time was above nyquist
                                       //(used to see if it needs interpolation)
+
+
+    Value_Smoothing_Filter freq_smoothing; /* for smoothing freq modulations to avoid zipper effect */
 };
 
 }
diff --git a/src/DSP/CMakeLists.txt b/src/DSP/CMakeLists.txt
index 84ac3853..b8be91b2 100644
--- a/src/DSP/CMakeLists.txt
+++ b/src/DSP/CMakeLists.txt
@@ -5,5 +5,6 @@ set(zynaddsubfx_dsp_SRCS
     DSP/FormantFilter.cpp
     DSP/SVFilter.cpp
     DSP/Unison.cpp
+    DSP/Value_Smoothing_Filter.cpp
     PARENT_SCOPE
 )
diff --git a/src/DSP/Value_Smoothing_Filter.cpp b/src/DSP/Value_Smoothing_Filter.cpp
new file mode 100644
index 00000000..c125b53a
--- /dev/null
+++ b/src/DSP/Value_Smoothing_Filter.cpp
@@ -0,0 +1,65 @@
+
+/*******************************************************************************/
+/* Copyright (C) 2008-2020 Jonathan Moore Liles                                */
+/*                                                                             */
+/* This program is free software; you can redistribute it and/or modify it     */
+/* under the terms of the GNU General Public License as published by the       */
+/* Free Software Foundation; either version 2 of the License, or (at your      */
+/* option) any later version.                                                  */
+/*                                                                             */
+/* This program is distributed in the hope that it will be useful, but WITHOUT */
+/* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or       */
+/* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for   */
+/* more details.                                                               */
+/*                                                                             */
+/* You should have received a copy of the GNU General Public License along     */
+/* with This program; see the file COPYING.  If not,write to the Free Software */
+/* Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+/*******************************************************************************/
+
+#include "Value_Smoothing_Filter.h"
+#include <math.h>
+
+void
+Value_Smoothing_Filter::sample_rate ( nframes_t n )
+{
+    const float FS = n;
+    const float T = 0.05f;
+	    
+    w = _cutoff / (FS * T);
+}
+    
+bool
+Value_Smoothing_Filter::apply( sample_t * __restrict__ dst, nframes_t nframes, float gt )
+{
+    if ( target_reached(gt) )
+	return false;
+	    
+    /* sample_t * dst_ = (sample_t*) assume_aligned(dst); */
+    sample_t * dst_ = (sample_t*)(dst);
+	    
+    const float a = 0.07f;
+    const float b = 1 + a;
+	    
+    const float gm = b * gt;
+	    
+    float g1 = this->g1;
+    float g2 = this->g2;
+	    
+    for (nframes_t i = 0; i < nframes; i++)
+    {
+	g1 += w * (gm - g1 - a * g2);
+	g2 += w * (g1 - g2);
+	dst_[i] = g2;
+    }
+	    
+    g2 += 1e-10f;		/* denormal protection */
+	    
+    if ( fabsf( gt - g2 ) < 0.0001f )
+	g2 = gt;
+	    
+    this->g1 = g1;
+    this->g2 = g2;
+	    
+    return true;
+}
diff --git a/src/DSP/Value_Smoothing_Filter.h b/src/DSP/Value_Smoothing_Filter.h
new file mode 100644
index 00000000..43179df2
--- /dev/null
+++ b/src/DSP/Value_Smoothing_Filter.h
@@ -0,0 +1,47 @@
+
+/*******************************************************************************/
+/* Copyright (C) 2008-2020 Jonathan Moore Liles                                */
+/*                                                                             */
+/* This program is free software; you can redistribute it and/or modify it     */
+/* under the terms of the GNU General Public License as published by the       */
+/* Free Software Foundation; either version 2 of the License, or (at your      */
+/* option) any later version.                                                  */
+/*                                                                             */
+/* This program is distributed in the hope that it will be useful, but WITHOUT */
+/* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or       */
+/* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for   */
+/* more details.                                                               */
+/*                                                                             */
+/* You should have received a copy of the GNU General Public License along     */
+/* with This program; see the file COPYING.  If not,write to the Free Software */
+/* Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+/*******************************************************************************/
+
+typedef unsigned long nframes_t;
+typedef float sample_t;
+
+class Value_Smoothing_Filter
+{
+    float w, g1, g2;
+    
+    float _cutoff;
+
+public:
+
+    Value_Smoothing_Filter ( )
+	{
+	    g1 = g2 = 0;
+	    _cutoff = 10.0f;
+	}
+
+    void cutoff ( float v ) { _cutoff = v; }
+
+    void reset ( float v ) { g2 = g1 = v; }
+
+    inline bool target_reached ( float gt ) const { return gt == g2; }
+
+    void sample_rate ( nframes_t n );
+	
+    bool apply( sample_t * __restrict__ dst, nframes_t nframes, float gt );
+};
+
-- 
2.47.0

