From bd90c016e40acbfc48a3c5a5ba515add0862ea1f Mon Sep 17 00:00:00 2001
From: fundamental <mark.d.mccurry@gmail.com>
Date: Sun, 23 Jul 2017 14:26:27 -0400
Subject: [PATCH 1174/1936] Take two at fixing usleep on windows

---
 src/Misc/MiddleWare.cpp |  8 ++------
 src/Misc/Util.cpp       | 23 ++++++++++++++++++++++-
 src/Misc/Util.h         |  2 +-
 src/Nio/NulEngine.cpp   |  6 ++----
 4 files changed, 27 insertions(+), 12 deletions(-)

diff --git a/src/Misc/MiddleWare.cpp b/src/Misc/MiddleWare.cpp
index d1817d42..1bce7737 100644
--- a/src/Misc/MiddleWare.cpp
+++ b/src/Misc/MiddleWare.cpp
@@ -48,8 +48,6 @@
 #include <string>
 #include <future>
 #include <atomic>
-#include <chrono>
-#include <thread>
 #include <list>
 
 #define errx(...) {}
@@ -1556,7 +1554,6 @@ MiddleWareImpl::~MiddleWareImpl(void)
 
 void MiddleWareImpl::doReadOnlyOp(std::function<void()> read_only_fn)
 {
-    using namespace std::chrono;
     assert(uToB);
     uToB->write("/freeze_state","");
 
@@ -1564,7 +1561,7 @@ void MiddleWareImpl::doReadOnlyOp(std::function<void()> read_only_fn)
     int tries = 0;
     while(tries++ < 10000) {
         if(!bToU->hasNext()) {
-            std::this_thread::sleep_for(microseconds(500));
+            os_usleep(500);
             continue;
         }
         const char *msg = bToU->read();
@@ -1670,7 +1667,6 @@ void MiddleWareImpl::doReadOnlyOpPlugin(std::function<void()> read_only_fn)
 
 bool MiddleWareImpl::doReadOnlyOpNormal(std::function<void()> read_only_fn, bool canfail)
 {
-    using namespace std::chrono;
     assert(uToB);
     uToB->write("/freeze_state","");
 
@@ -1678,7 +1674,7 @@ bool MiddleWareImpl::doReadOnlyOpNormal(std::function<void()> read_only_fn, bool
     int tries = 0;
     while(tries++ < 2000) {
         if(!bToU->hasNext()) {
-            std::this_thread::sleep_for(microseconds(500));
+            os_usleep(500);
             continue;
         }
         const char *msg = bToU->read();
diff --git a/src/Misc/Util.cpp b/src/Misc/Util.cpp
index e767e6b0..3db3457f 100644
--- a/src/Misc/Util.cpp
+++ b/src/Misc/Util.cpp
@@ -129,10 +129,31 @@ void set_realtime()
 #endif
 }
 
-void os_sleep(long length)
+
+
+#ifdef WIN32
+#include <windows.h>
+
+//https://stackoverflow.com/questions/5801813/c-usleep-is-obsolete-workarounds-for-windows-mingw
+void os_usleep(long usec)
+{
+    HANDLE timer;
+    LARGE_INTEGER ft;
+
+    ft.QuadPart = -(10*usec); // Convert to 100 nanosecond interval, negative value indicates relative time
+
+    timer = CreateWaitableTimer(NULL, TRUE, NULL);
+    SetWaitableTimer(timer, &ft, 0, NULL, NULL, 0);
+    WaitForSingleObject(timer, INFINITE);
+    CloseHandle(timer);
+}
+#else
+
+void os_usleep(long length)
 {
     usleep(length);
 }
+#endif
 
 //!< maximum lenght a pid has on any POSIX system
 //!< this is an estimation, but more than 12 looks insane
diff --git a/src/Misc/Util.h b/src/Misc/Util.h
index 15bc79a2..1b054db9 100644
--- a/src/Misc/Util.h
+++ b/src/Misc/Util.h
@@ -46,7 +46,7 @@ extern float getdetune(unsigned char type,
 void set_realtime();
 
 /**Os independent sleep in microsecond*/
-void os_sleep(long length);
+void os_usleep(long length);
 
 //! returns pid padded to maximum pid lenght, posix conform
 std::string os_pid_as_padded_string();
diff --git a/src/Nio/NulEngine.cpp b/src/Nio/NulEngine.cpp
index e9aa260a..bc0edde5 100644
--- a/src/Nio/NulEngine.cpp
+++ b/src/Nio/NulEngine.cpp
@@ -13,9 +13,8 @@
 
 #include "NulEngine.h"
 #include "../globals.h"
+#include "../Misc/Util.h"
 
-#include <thread>
-#include <chrono>
 #include <iostream>
 using namespace std;
 
@@ -36,7 +35,6 @@ void *NulEngine::_AudioThread(void *arg)
 
 void *NulEngine::AudioThread()
 {
-    using namespace std::chrono;
     while(pThread) {
         getNext();
 
@@ -52,7 +50,7 @@ void *NulEngine::AudioThread()
                         + (playing_until.tv_sec - now.tv_sec) * 1000000;
             if(remaining > 10000) //Don't sleep() less than 10ms.
                 //This will add latency...
-                std::this_thread::sleep_for(std::chrono::microseconds(remaining  - 10000));
+                os_usleep(remaining  - 10000);
             if(remaining < 0)
                 cerr << "WARNING - too late" << endl;
         }
-- 
2.47.0

