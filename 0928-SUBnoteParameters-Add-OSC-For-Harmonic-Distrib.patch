From d920f8b046d9797a3af2ff9251db5b7e52d4c395 Mon Sep 17 00:00:00 2001
From: fundamental <mark.d.mccurry@gmail.com>
Date: Mon, 13 Jun 2016 16:08:52 -0400
Subject: [PATCH 0928/1936] SUBnoteParameters: Add OSC For Harmonic Distrib

---
 rtosc                            |   2 +-
 src/Params/SUBnoteParameters.cpp | 174 ++++++++++++++++++++++++-------
 src/Params/SUBnoteParameters.h   |  11 +-
 src/Synth/SUBnote.cpp            |  60 +++--------
 4 files changed, 157 insertions(+), 90 deletions(-)

diff --git a/rtosc b/rtosc
index 3c46df0c..4ab80cbd 160000
--- a/rtosc
+++ b/rtosc
@@ -1 +1 @@
-Subproject commit 3c46df0cd36fe04f43df794875d503ebea512312
+Subproject commit 4ab80cbda6be312e9ef8e5ffea573e7701ed30cc
diff --git a/src/Params/SUBnoteParameters.cpp b/src/Params/SUBnoteParameters.cpp
index 44a75b34..2522de31 100644
--- a/src/Params/SUBnoteParameters.cpp
+++ b/src/Params/SUBnoteParameters.cpp
@@ -26,6 +26,11 @@
 #define rObject SUBnoteParameters
 using namespace rtosc;
 
+#define rBegin [](const char *msg, RtData &d) { \
+    SUBnoteParameters *obj = (SUBnoteParameters*) d.obj
+#define rEnd }
+
+
 #undef rChangeCb
 #define rChangeCb if (obj->time) { obj->last_update_timestamp = obj->time->time(); }
 static const rtosc::Ports SUBnotePorts = {
@@ -77,52 +82,91 @@ static const rtosc::Ports SUBnotePorts = {
     rRecurp(GlobalFilter,         "Post Filter"),
     rOption(Pstart, rShort("initial"), rOptions(zero, random, ones), "How harmonics are initialized"),
 
-    {"clear:", rDoc("Reset all harmonics to equal bandwidth/zero amplitude"), NULL, [](const char *, RtData &d)
-        {
-            SUBnoteParameters *obj = (SUBnoteParameters *)d.obj;
-            for(int i=0; i<MAX_SUB_HARMONICS; ++i) {
-                obj->Phmag[i]   = 0;
-                obj->Phrelbw[i] = 64;
-            }
-            obj->Phmag[0] = 127;
-        }},
-    {"detunevalue:", rDoc("Get note detune value"), NULL, [](const char *, RtData &d)
-        {
-            SUBnoteParameters *obj = (SUBnoteParameters *)d.obj;
-            d.reply(d.loc, "f", getdetune(obj->PDetuneType, 0, obj->PDetune));
-        }},
+    {"clear:", rDoc("Reset all harmonics to equal bandwidth/zero amplitude"), NULL,
+        rBegin;
+        for(int i=0; i<MAX_SUB_HARMONICS; ++i) {
+            obj->Phmag[i]   = 0;
+            obj->Phrelbw[i] = 64;
+        }
+        obj->Phmag[0] = 127;
+        rEnd},
+    {"detunevalue:", rDoc("Get note detune value"), NULL,
+        rBegin;
+        d.reply(d.loc, "f", getdetune(obj->PDetuneType, 0, obj->PDetune));
+        rEnd},
     //weird stuff for PCoarseDetune
     {"octave::c:i", rProp(parameter) rDoc("Note octave shift"), NULL,
-        [](const char *msg, RtData &d)
-        {
-            SUBnoteParameters *obj = (SUBnoteParameters *)d.obj;
-            if(!rtosc_narguments(msg)) {
-                int k=obj->PCoarseDetune/1024;
-                if (k>=8) k-=16;
-                d.reply(d.loc, "i", k);
-            } else {
-                int k=(int) rtosc_argument(msg, 0).i;
-                if (k<0) k+=16;
-                obj->PCoarseDetune = k*1024 + obj->PCoarseDetune%1024;
-            }
-        }},
+        rBegin;
+        if(!rtosc_narguments(msg)) {
+            int k=obj->PCoarseDetune/1024;
+            if (k>=8) k-=16;
+            d.reply(d.loc, "i", k);
+        } else {
+            int k=(int) rtosc_argument(msg, 0).i;
+            if (k<0) k+=16;
+            obj->PCoarseDetune = k*1024 + obj->PCoarseDetune%1024;
+        }
+        rEnd},
     {"coarsedetune::c:i", rProp(parameter) rDoc("Note coarse detune"), NULL,
-        [](const char *msg, RtData &d)
-        {
-            SUBnoteParameters *obj = (SUBnoteParameters *)d.obj;
-            if(!rtosc_narguments(msg)) {
-                int k=obj->PCoarseDetune%1024;
-                if (k>=512) k-=1024;
-                d.reply(d.loc, "i", k);
-            } else {
-                int k=(int) rtosc_argument(msg, 0).i;
-                if (k<0) k+=1024;
-                obj->PCoarseDetune = k + (obj->PCoarseDetune/1024)*1024;
-            }
-        }},
+        rBegin;
+        if(!rtosc_narguments(msg)) {
+            int k=obj->PCoarseDetune%1024;
+            if (k>=512) k-=1024;
+            d.reply(d.loc, "i", k);
+        } else {
+            int k=(int) rtosc_argument(msg, 0).i;
+            if (k<0) k+=1024;
+            obj->PCoarseDetune = k + (obj->PCoarseDetune/1024)*1024;
+        }
+        rEnd},
+    {"response:", rDoc("Filter response at 440Hz. with 48kHz sample rate\n\n"
+            "Format: stages, filter*active_filters\n"
+            "        filter = [frequency, bandwidth, amplitude]"),
+    NULL,
+    rBegin;
+
+    //Identify the active harmonics
+    int pos[MAX_SUB_HARMONICS];
+    int harmonics;
+    obj->activeHarmonics(pos, harmonics);
+
+    float base_freq = 440.0f;
+
+    char        types[3*MAX_SUB_HARMONICS+2];
+    rtosc_arg_t args[3*MAX_SUB_HARMONICS+1];
+
+    args[0].i = obj->Pnumstages;
+    types[0]  = 'i';
+
+    for(int n=0; n<harmonics; ++n) {
+        const float freq = base_freq * obj->POvertoneFreqMult[pos[n]];
+        //the bandwidth is not absolute(Hz); it is relative to frequency
+        const float bw = obj->convertBandwidth(obj->Pbandwidth,
+                obj->Pnumstages, freq, obj->Pbwscale, obj->Phrelbw[pos[n]]);
+
+        //try to keep same amplitude on all freqs and bw. (empirically)
+        const float hgain = obj->convertHarmonicMag(obj->Phmag[pos[n]],
+                                                    obj->Phmagtype);
+        const float gain  = hgain * sqrt(1500.0f / (bw * freq));
+
+        int base = 1+3*n;
+        args[base + 0].f = freq;
+        args[base + 1].f = bw;
+        args[base + 2].f = gain;
+        types[base + 0] = 'f';
+        types[base + 1] = 'f';
+        types[base + 2] = 'f';
+    }
+
+    types[3*harmonics+1] = 0;
+    d.replyArray(d.loc, types, args);
+    rEnd},
+
 
 };
 #undef rChangeCb
+#undef rBegin
+#undef rEnd
 
 const rtosc::Ports &SUBnoteParameters::ports = SUBnotePorts;
 
@@ -144,6 +188,56 @@ SUBnoteParameters::SUBnoteParameters(const AbsTime *time_)
     defaults();
 }
 
+void SUBnoteParameters::activeHarmonics(int *pos, int &harmonics) const
+{
+    harmonics = 0;
+    for(int n = 0; n < MAX_SUB_HARMONICS; ++n) {
+        if(Phmag[n] == 0)
+            continue;
+        pos[harmonics++] = n;
+    }
+}
+
+float SUBnoteParameters::convertBandwidth(int bw_, int stages, float freq,
+        int scale, int relbw)
+{
+    //the bandwidth is not absolute(Hz); it is relative to frequency
+    float bw = powf(10, (bw_ - 127.0f) / 127.0f * 4) * stages;
+
+    //Bandwidth Scale
+    bw *= powf(1000 / freq, (scale - 64.0f) / 64.0f * 3.0f);
+
+    //Relative BandWidth
+    bw *= powf(100, (relbw - 64.0f) / 64.0f);
+
+    if(bw > 25.0f)
+        bw = 25.0f;
+
+    return bw;
+}
+
+float SUBnoteParameters::convertHarmonicMag(int mag, int type)
+{
+    const float hmagnew = 1.0f - mag / 127.0f;
+
+    switch(type) {
+        case 1:
+            return expf(hmagnew * logf(0.01f));
+            break;
+        case 2:
+            return expf(hmagnew * logf(0.001f));
+            break;
+        case 3:
+            return expf(hmagnew * logf(0.0001f));
+            break;
+        case 4:
+            return expf(hmagnew * logf(0.00001f));
+            break;
+        default:
+            return 1.0f - hmagnew;
+    }
+}
+
 
 void SUBnoteParameters::defaults()
 {
diff --git a/src/Params/SUBnoteParameters.h b/src/Params/SUBnoteParameters.h
index f5f6c8ec..b5385765 100644
--- a/src/Params/SUBnoteParameters.h
+++ b/src/Params/SUBnoteParameters.h
@@ -24,6 +24,15 @@ class SUBnoteParameters:public Presets
         SUBnoteParameters(const AbsTime *time_ = nullptr);
         ~SUBnoteParameters();
 
+        //Identify active harmonic positions
+        // - pos       : int[MAX_SUB_HARMONICS] offsets of active harmonics
+        // - harmonics : number of active harmonics
+        void activeHarmonics(int *pos, int &harmonics) const;
+
+        static float convertBandwidth(int bw, int stages, float freq,
+                int scale, int relbw);
+        static float convertHarmonicMag(int mag, int type);
+
         void add2XML(XMLwrapper& xml);
         void defaults();
         void getfromXML(XMLwrapper& xml);
@@ -31,7 +40,7 @@ class SUBnoteParameters:public Presets
         void paste(SUBnoteParameters &sub);
 
         //Parameters
-        //AMPLITUDE PARAMETRERS
+        //AMPLITUDE PARAMETERS
         unsigned char   Pstereo; //0 for mono,1 for stereo
         unsigned char   PVolume;
         unsigned char   PPanning;
diff --git a/src/Synth/SUBnote.cpp b/src/Synth/SUBnote.cpp
index 3af36d13..d49c433a 100644
--- a/src/Synth/SUBnote.cpp
+++ b/src/Synth/SUBnote.cpp
@@ -48,46 +48,19 @@ float SUBnote::setupFilters(int *pos, bool automation)
     float reduceamp = 0.0f;
 
     for(int n = 0; n < numharmonics; ++n) {
-        float freq =  basefreq * pars.POvertoneFreqMult[pos[n]];
+        const float freq =  basefreq * pars.POvertoneFreqMult[pos[n]];
         overtone_freq[n] = freq;
         overtone_rolloff[n] = computerolloff(freq);
 
         //the bandwidth is not absolute(Hz); it is relative to frequency
-        float bw =
-            powf(10, (pars.Pbandwidth - 127.0f) / 127.0f * 4) * numstages;
-
-        //Bandwidth Scale
-        bw *= powf(1000 / freq, (pars.Pbwscale - 64.0f) / 64.0f * 3.0f);
-
-        //Relative BandWidth
-        bw *= powf(100, (pars.Phrelbw[pos[n]] - 64.0f) / 64.0f);
-
-        if(bw > 25.0f)
-            bw = 25.0f;
+        const float bw = SUBnoteParameters::convertBandwidth(pars.Pbandwidth,
+                numstages, freq, pars.Pbwscale, pars.Phrelbw[pos[n]]);
 
         //try to keep same amplitude on all freqs and bw. (empirically)
-        float gain = sqrt(1500.0f / (bw * freq));
-
-        float hmagnew = 1.0f - pars.Phmag[pos[n]] / 127.0f;
-        float hgain;
-
-        switch(pars.Phmagtype) {
-            case 1:
-                hgain = expf(hmagnew * logf(0.01f));
-                break;
-            case 2:
-                hgain = expf(hmagnew * logf(0.001f));
-                break;
-            case 3:
-                hgain = expf(hmagnew * logf(0.0001f));
-                break;
-            case 4:
-                hgain = expf(hmagnew * logf(0.00001f));
-                break;
-            default:
-                hgain = 1.0f - hmagnew;
-        }
-        gain      *= hgain;
+        const float hgain = SUBnoteParameters::convertHarmonicMag(pars.Phmag[pos[n]],
+                pars.Phmagtype);
+        const float gain  = hgain * sqrt(1500.0f / (bw * freq));
+
         reduceamp += hgain;
 
         for(int nph = 0; nph < numstages; ++nph) {
@@ -160,14 +133,10 @@ void SUBnote::setup(float freq,
 //    basefreq*=ctl.pitchwheel.relfreq;//pitch wheel
 
     int pos[MAX_SUB_HARMONICS];
-    int harmonics = 0;
+    int harmonics;
+
+    pars.activeHarmonics(pos, harmonics);
 
-    //select only harmonics that desire to compute
-    for(int n = 0; n < MAX_SUB_HARMONICS; ++n) {
-        if(pars.Phmag[n] == 0)
-            continue;
-        pos[harmonics++] = n;
-    }
     if(!legato) //normal note
         firstnumharmonics = numharmonics = harmonics;
     else {
@@ -438,14 +407,9 @@ void SUBnote::computecurrentparameters()
         //A little bit of copy/paste for now
 
         int pos[MAX_SUB_HARMONICS];
-        int harmonics = 0;
+        int harmonics;
 
-        //select only harmonics that desire to compute
-        for(int n = 0; n < MAX_SUB_HARMONICS; ++n) {
-            if(pars.Phmag[n] == 0)
-                continue;
-            pos[harmonics++] = n;
-        }
+        pars.activeHarmonics(pos, harmonics);
 
         bool delta_harmonics = (harmonics != numharmonics);
         if(delta_harmonics) {
-- 
2.47.0

