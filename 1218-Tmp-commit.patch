From 31ecef0aeb7a321c9921ce856bf400b96bd68ed9 Mon Sep 17 00:00:00 2001
From: Johannes Lorenz <johannes89@ist-einmalig.de>
Date: Mon, 30 Oct 2017 07:27:59 +0100
Subject: [PATCH 1218/1936] Tmp commit

---
 TODO.txt                 |  7 +++-
 doc/architecture.txt     | 21 +++++-----
 src/Misc/Master.cpp      |  4 +-
 src/Misc/MiddleWare.cpp  | 88 ++++++++++++++++++++--------------------
 src/Tests/CMakeLists.txt |  2 +-
 src/Tests/SaveOSC.cpp    | 20 ++++++---
 6 files changed, 79 insertions(+), 63 deletions(-)

diff --git a/TODO.txt b/TODO.txt
index 7bdc0b60..0bdea5ee 100644
--- a/TODO.txt
+++ b/TODO.txt
@@ -1,6 +1,9 @@
-* get position of bundle in a path
-* fix sleep => wait correctly
+TODOs for default values:
+* iterate correctly over arrays
 * use b (or #?) for bundles, not a
+move code:
+ports.cpp => default_values.cpp
+rtosc.cpp => ...cmp.cpp?
 test:
 * zyn fx (all presets)
 * rtosc arg val maths
diff --git a/doc/architecture.txt b/doc/architecture.txt
index 2df1d658..868bb92a 100644
--- a/doc/architecture.txt
+++ b/doc/architecture.txt
@@ -132,17 +132,18 @@ This is where the nice pristine hands off approach sadly comes to an end.
 There simply isn't an effective means of capturing all parameters without
 taking a large amount of time.
 
-In order to permit the serialization of parameter objects, the backend is 
-partially 'frozen'. The master has two kinds of variables:
- - The realtime variables which are only ever mutable through the RT thread
- - The non realtime variables which are only ever mutable through
-   * osc dispatch within Master
+The master has two kinds of parameter objects:
+ - Realtime variables which are only ever mutable through the RT thread
+ - Non realtime variables which are only ever mutable through
+   * OSC dispatch within Master
    * MiddleWare (using struct NonRtObjStore)
-Partially means that only the second kind of variable is ever being saved.
-Since the freezing message is the last one the middleware sends, this
-essentially prevents the backend from processing most messages from the
-user interface and when this occurs the parameters which are to be serialized
-can be guaranteed to be constant and thus safe to access across threads.
+Now, in order to permit the serialization of parameter objects, the backend is
+partially 'frozen'. 'Partially' means that only the non realtime variables are
+ever being saved. Since the freezing message is the last one the MiddleWare
+sends, this essentially prevents the backend from processing further messages
+from the user interface and when this occurs the parameters which are to be
+serialized can be guaranteed to be constant and thus safe to access across
+threads.
 
 This class of read-only-operation can be seen as used in parameter copy/paste
 operations and in saving full instances as well as instruments.
diff --git a/src/Misc/Master.cpp b/src/Misc/Master.cpp
index 51b40b31..6041a2a8 100644
--- a/src/Misc/Master.cpp
+++ b/src/Misc/Master.cpp
@@ -1656,7 +1656,7 @@ char* Master::getXMLData()
     return xml.getXMLdata();
 }
 
-// this is being called as a "read only op" directly by MiddleWare or the UI;
+// this is being called as a "read only op" directly by the MiddleWare thread;
 // note that the Master itself is frozen
 int Master::saveOSC(const char *filename, master_dispatcher_t* dispatcher,
                     Master* master2)
@@ -1672,7 +1672,7 @@ int Master::saveOSC(const char *filename, master_dispatcher_t* dispatcher,
 
     int rval = master2->loadOSCFromStr(savefile.c_str(), dispatcher);
 
-    // The above call is in this thread (i.e. called by MiddleWare or UI), but
+    // The above call is done by this thread (i.e. the MiddleWare thread), but
     // it sends messages to master2 in order to load the values
     // We need to wait until savefile has been loaded into master2
     int i;
diff --git a/src/Misc/MiddleWare.cpp b/src/Misc/MiddleWare.cpp
index 6c6f9b1c..ce54e7f0 100644
--- a/src/Misc/MiddleWare.cpp
+++ b/src/Misc/MiddleWare.cpp
@@ -584,6 +584,37 @@ public:
         parent->transmitMsg("/load-master", "b", sizeof(Master*), &m);
     }
 
+    int saveMaster(const char *filename, bool osc_format = false)
+    {
+        int res;
+        if(osc_format)
+        {
+            mw_dispatcher_t dispatcher(parent);
+
+            // allocate an "empty" master
+            // after the savefile will have been saved, it will be loaded into this
+            // dummy master, and then the two masters will be compared
+            zyn::Config config;
+            zyn::SYNTH_T* synth = new zyn::SYNTH_T;
+            synth->buffersize = master->synth.buffersize;
+            synth->samplerate = master->synth.samplerate;
+            synth->alias();
+            zyn::Master master2(*synth, &config);
+            master->copyMasterCbTo(&master2);
+            master2.frozenState = true;
+
+            doReadOnlyOp([this,filename,&dispatcher,&master2,&res](){
+                             res = master->saveOSC(filename, &dispatcher,
+                                                   &master2);});
+        }
+        else // xml format
+        {
+            doReadOnlyOp([this,filename,&res](){
+                             res = master->saveXML(filename);});
+        }
+        return res;
+    }
+
     void loadXsz(const char *filename, rtosc::RtData &d)
     {
         Microtonal *micro = new Microtonal(master->gzip_compression);
@@ -808,16 +839,16 @@ class MwDataObj:public rtosc::RtData
                 reply(buffer);
             }
         }
-        //! In the case of MiddleWare, reply always means sending back to
+        //! In the case of MiddleWare, "reply" always means sending back to
         //! the front-end. If a message from the back-end gets "replied", this
-        //! only means that it has been sent from the front-end via MiddleWare
-        //! to the backend, so the reply has to go to the front-end.
-        //! The back-end itself usually doesn't ask things, so it does not
-        //! get replies.
+        //! only means that its counterpart has been sent from the front-end via
+        //! MiddleWare to the backend, so the reply has to go back to the
+        //! front-end. The back-end itself usually doesn't ask things, so it
+        //! will not get replies.
         virtual void reply(const char *msg) override{
             mwi->sendToCurrentRemote(msg);
         }
-        //virtual void broadcast(const char *path, const char *args, ...){(void)path;(void)args;};
+
         virtual void broadcast(const char *msg) override {
             mwi->broadcastToRemote(msg);
         }
@@ -1144,6 +1175,9 @@ const rtosc::Ports bankPorts = {
 #define STRINGIFY(a) STRINGIFY2(a)
 #endif
 
+/*
+ * common snoop port callbacks
+ */
 template<bool osc_format>
 void load_cb(const char *msg, RtData &d)
 {
@@ -1158,8 +1192,8 @@ void load_cb(const char *msg, RtData &d)
     d.broadcast(d.loc, "stT", file, request_time);
 }
 
-void save_cb(const char *msg, RtData &d,
-             std::function<int(MiddleWareImpl&, const std::string&)>& cb)
+template<bool osc_format>
+void save_cb(const char *msg, RtData &d)
 {
     MiddleWareImpl &impl = *((MiddleWareImpl*)d.obj);
     // Due to a possible bug in ThreadLink, filename may get trashed when
@@ -1169,43 +1203,11 @@ void save_cb(const char *msg, RtData &d,
     if(rtosc_narguments(msg) > 1)
         request_time = rtosc_argument(msg, 1).t;
 
-    int res = cb(impl, file); // the actual saving
-
+    int res = impl.saveMaster(file.c_str(), osc_format);
     d.broadcast(d.loc, (res == 0) ? "stT" : "stF",
                 file.c_str(), request_time);
 }
 
-int save_osc(MiddleWareImpl& impl, const std::string& file)
-{
-    mw_dispatcher_t dispatcher(impl.parent);
-
-    // allocate an "empty" master
-    // after the savefile will have been saved, it will be loaded into this
-    // dummy master, and then the two masters will be compared
-    zyn::Config config;
-    zyn::SYNTH_T* synth = new zyn::SYNTH_T;
-    synth->buffersize = impl.master->synth.buffersize;
-    synth->samplerate = impl.master->synth.samplerate;
-    synth->alias();
-    zyn::Master master2(*synth, &config);
-    impl.master->copyMasterCbTo(&master2);
-    master2.frozenState = true;
-
-    int res;
-    impl.doReadOnlyOp([&impl,file,&dispatcher,&master2,&res](){
-            res = impl.master->saveOSC(file.c_str(), &dispatcher,
-                                       &master2);});
-    return res;
-}
-
-int save_xml(MiddleWareImpl& impl, const std::string& file)
-{
-    int res;
-    impl.doReadOnlyOp([&impl,file, &res](){
-            res = impl.master->saveXML(file.c_str());});
-    return res;
-}
-
 /*
  * BASE/part#/kititem#
  * BASE/part#/kit#/adpars/voice#/oscil/\*
@@ -1314,8 +1316,8 @@ static rtosc::Ports middwareSnoopPorts = {
         const char *file = rtosc_argument(msg, 0).s;
         impl.loadKbm(file, d);
         rEnd},
-    {"save_xmz:s:st", 0, 0, save_cb<save_xml>},
-    {"save_osc:s:st", 0, 0, save_cb<save_osc>},
+    {"save_xmz:s:st", 0, 0, save_cb<false>},
+    {"save_osc:s:st", 0, 0, save_cb<true>},
     {"save_xiz:is", 0, 0,
         rBegin;
         const int   part_id = rtosc_argument(msg,0).i;
diff --git a/src/Tests/CMakeLists.txt b/src/Tests/CMakeLists.txt
index fdbe8e03..22e2e675 100644
--- a/src/Tests/CMakeLists.txt
+++ b/src/Tests/CMakeLists.txt
@@ -65,7 +65,7 @@ add_executable(ins-test InstrumentStats.cpp)
 target_link_libraries(ins-test ${test_lib} rt)
 
 add_executable(save-osc SaveOSC.cpp)
-target_link_libraries(save-osc rtosc
+target_link_libraries(save-osc
                       zynaddsubfx_core zynaddsubfx_nio
                       zynaddsubfx_gui_bridge
                       ${GUI_LIBRARIES} ${NIO_LIBRARIES} ${AUDIO_LIBRARIES})
diff --git a/src/Tests/SaveOSC.cpp b/src/Tests/SaveOSC.cpp
index ae841c54..d1bd31ea 100644
--- a/src/Tests/SaveOSC.cpp
+++ b/src/Tests/SaveOSC.cpp
@@ -2,6 +2,7 @@
 #include <thread>
 #include <mutex>
 #include <iostream>
+#include <ctime>
 #include <unistd.h>
 #include <rtosc/thread-link.h>
 #include <rtosc/rtosc-time.h>
@@ -68,8 +69,10 @@ class SaveOSCTest
         std::mutex cb_mutex;
         using mutex_guard = std::lock_guard<std::mutex>;
 
-        bool timedOperation(const char* osc_path, const char* arg1, int tries)
+        bool timeOutOperation(const char* osc_path, const char* arg1, int tries)
         {
+            clock_t begin = clock(); // just for statistics
+
             bool ok = false;
             rtosc_arg_val_t start_time;
             rtosc_arg_val_current_time(&start_time);
@@ -90,10 +93,17 @@ class SaveOSCTest
                 usleep(1000);
             }
 
-            fprintf(stderr, "Action %s terminated after %d tries (%s)\n",
-                    osc_path, attempt,
+            // statistics:
+            clock_t end = clock();
+            double elapsed_secs = double(end - begin) / CLOCKS_PER_SEC;
+
+            fprintf(stderr, "Action %s finished after %lf ms,\n"
+                            "    with a timeout of <%d ms (%s)\n",
+                    osc_path, elapsed_secs,
+                    attempt+1,
                     attempt == tries ? "timeout"
                                      : ok ? "ok" : "failure");
+
             return ok && (attempt != tries);
         }
 
@@ -129,13 +139,13 @@ class SaveOSCTest
             int rval;
 
             fputs("Loading XML file...\n", stderr);
-            if(timedOperation("/load_xmz", filename, 1000))
+            if(timeOutOperation("/load_xmz", filename, 1000))
             {
                 fputs("Saving OSC file now...\n", stderr);
                 // There is actually no need to wait for /save_osc, since
                 // we're in the "UI" thread which does the saving itself,
                 // but this gives an example how it works with remote fron-ends
-                rval = timedOperation("/save_osc", filename, 1000)
+                rval = timeOutOperation("/save_osc", filename, 1000)
                      ? EXIT_SUCCESS
                      : EXIT_FAILURE;
             }
-- 
2.47.0

