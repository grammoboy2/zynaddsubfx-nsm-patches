From e42a284dd66595140c5e6c0db93d357f7e2f8b30 Mon Sep 17 00:00:00 2001
From: fundamental <mark.d.mccurry@gmail.com>
Date: Thu, 23 Oct 2014 15:39:56 -0400
Subject: [PATCH 0260/1936] Cleaning MiddleWare

---
 src/Misc/MiddleWare.cpp | 672 ++++++++++++++++++++++------------------
 src/Misc/MiddleWare.h   |   9 +-
 2 files changed, 376 insertions(+), 305 deletions(-)

diff --git a/src/Misc/MiddleWare.cpp b/src/Misc/MiddleWare.cpp
index d940f1ff..185c1542 100644
--- a/src/Misc/MiddleWare.cpp
+++ b/src/Misc/MiddleWare.cpp
@@ -30,9 +30,13 @@
 rtosc::ThreadLink *bToU = new rtosc::ThreadLink(4096*2,1024);
 rtosc::ThreadLink *uToB = new rtosc::ThreadLink(4096*2,1024);
 
-/**
- * General local static code/data
- */
+/******************************************************************************
+ *                        LIBLO And Reflection Code                           *
+ *                                                                            *
+ * All messages that are handled are handled in a serial fashion.             *
+ * Thus, changes in the current interface sending messages can be encoded     *
+ * into the stream via events which simply echo back the active interface     *
+ ******************************************************************************/
 static lo_server server;
 static string last_url, curr_url;
 
@@ -129,6 +133,9 @@ static int handler_function(const char *path, const char *types, lo_arg **argv,
 typedef void(*cb_t)(void*,const char*);
 
 
+/*****************************************************************************
+ *                    Memory Deallocation                                    *
+ *****************************************************************************/
 void deallocate(const char *str, void *v)
 {
     printf("deallocating a '%s' at '%p'\n", str, v);
@@ -143,6 +150,9 @@ void deallocate(const char *str, void *v)
 }
 
 
+/*****************************************************************************
+ *                    PadSynth Setup                                         *
+ *****************************************************************************/
 
 void preparePadSynth(string path, PADnoteParameters *p)
 {
@@ -166,6 +176,16 @@ void preparePadSynth(string path, PADnoteParameters *p)
     }
 }
 
+/*****************************************************************************
+ *                       Instrument Banks                                    *
+ *                                                                           *
+ * Banks and presets in general are not classed as realtime safe             *
+ *                                                                           *
+ * The supported operations are:                                             *
+ * - Load Names                                                              *
+ * - Load Bank                                                               *
+ * - Refresh List of Banks                                                   *
+ *****************************************************************************/
 void refreshBankView(const Bank &bank, unsigned loc, Fl_Osc_Interface *osc)
 {
     if(loc >= BANK_SIZE)
@@ -219,6 +239,10 @@ void bankPos(Bank &bank, Fl_Osc_Interface *osc)
     osc->tryLink(response);
 }
 
+/*****************************************************************************
+ *                      Data Object for Non-RT Class Dispatch                *
+ *****************************************************************************/
+
 class DummyDataObj:public rtosc::RtData
 {
     public:
@@ -226,7 +250,6 @@ class DummyDataObj:public rtosc::RtData
                 Fl_Osc_Interface *osc_)
         {
             memset(loc_, 0, sizeof(loc_size_));
-            //XXX Possible bug in rtosc using this buffer
             buffer = new char[4*4096];
             memset(buffer, 0, 4*4096);
             loc      = loc_;
@@ -278,8 +301,20 @@ class DummyDataObj:public rtosc::RtData
 };
 
 
-//Storage For Objects which need to be interfaced with outside the realtime
-//thread (aka they have long lived operations which can be done out-of-band)
+/******************************************************************************
+ *                      Non-RealTime Object Store                             *
+ *                                                                            *
+ *                                                                            *
+ * Storage For Objects which need to be interfaced with outside the realtime  *
+ * thread (aka they have long lived operations which can be done out-of-band) *
+ *                                                                            *
+ * - OscilGen instances as prepare() cannot be done in realtime and PAD       *
+ *   depends on these instances                                               *
+ * - PADnoteParameter instances as applyparameters() cannot be done in        *
+ *   realtime                                                                 *
+ *                                                                            *
+ * These instances are collected on every part change and kit change          *
+ ******************************************************************************/
 struct NonRtObjStore
 {
     std::map<std::string, void*> objmap;
@@ -334,8 +369,19 @@ struct NonRtObjStore
     }
 };
 
-//Parameter Storage Used For Controlled/Safe Allocations
-//(and possibly saving/loading)
+/******************************************************************************
+ *                      Realtime Parameter Store                              *
+ *                                                                            *
+ * Storage for AD/PAD/SUB parameters which are allocated as needed by kits.   *
+ * Two classes of events affect this:                                         *
+ * 1. When a message to enable a kit is observed, then the kit is allocated   *
+ *    and sent prior to the enable message.                                   *
+ * 2. When a part is allocated all part information is rebuilt                *
+ *                                                                            *
+ * (NOTE pointers aren't really needed here, just booleans on whether it has  *
+ * been  allocated)                                                           *
+ * This may be later utilized for copy/paste support                          *
+ ******************************************************************************/
 struct ParamStore
 {
     ADnoteParameters  *add[NUM_MIDI_PARTS][NUM_KIT_ITEMS];
@@ -353,117 +399,15 @@ class MiddleWareImpl
     {
          return "/tmp/zynaddsubfx_" + to_s(getpid());
     }
-public:
-    MiddleWareImpl(void)
-    {
-        server = lo_server_new_with_proto(NULL, LO_UDP, liblo_error_cb);
-        lo_server_add_method(server, NULL, NULL, handler_function, NULL);
-        fprintf(stderr, "lo server running on %d\n", lo_server_get_port(server));
-        
-        {
-            std::string tmp_nam = get_tmp_nam();
-            if(0 == access(tmp_nam.c_str(), F_OK)) {
-                fprintf(stderr, "Error: Cannot overwrite file %s. "
-                    "You should probably remove it.", tmp_nam.c_str());
-                exit(EXIT_FAILURE);
-            }
-            FILE* tmp_fp = fopen(tmp_nam.c_str(), "w");
-            if(!tmp_fp)
-                fprintf(stderr, "Warning: could not create new file %s.\n",
-                    tmp_nam.c_str());
-            else
-                fprintf(tmp_fp, "%u", (unsigned)lo_server_get_port(server));
-            fclose(tmp_fp);
-        }
-
-        //dummy callback for starters
-        cb = [](void*, const char*){};
-        idle = 0;
-
-        master = new Master();
-        osc    = genOscInterface(this);
-
-        //Grab objects of interest from master
-        obj_store.extractMaster(master);
-
-        //Null out Load IDs
-        for(int i=0; i < NUM_MIDI_PARTS; ++i) {
-            pending_load[i] = 0;
-            actual_load[i] = 0;
-        }
-    }
-
-    ~MiddleWareImpl(void)
-    {
-        remove(get_tmp_nam().c_str());
-        
-        warnMemoryLeaks();
 
-        delete master;
-        delete osc;
-    }
+public:
+    MiddleWareImpl(void);
+    ~MiddleWareImpl(void);
 
     void warnMemoryLeaks(void);
-        
-    /** Threading When Saving
-     *  ----------------------
-     *
-     * Procedure Middleware: 
-     *   1) Middleware sends /freeze_state to backend
-     *   2) Middleware waits on /state_frozen from backend
-     *      All intervening commands are held for out of order execution
-     *   3) Aquire memory
-     *      At this time by the memory barrier we are guarenteed that all old
-     *      writes are done and assuming the freezing logic is sound, then it is
-     *      impossible for any other parameter to change at this time
-     *   3) Middleware performs saving operation
-     *   4) Middleware sends /thaw_state to backend
-     *   5) Restore in order execution
-     *
-     * Procedure Backend:
-     *   1) Observe /freeze_state and disable all mutating events (MIDI CC)
-     *   2) Run a memory release to ensure that all writes are complete
-     *   3) Send /state_frozen to Middleware
-     *   time...
-     *   4) Observe /thaw_state and resume normal processing
-     */
-
-    void doReadOnlyOp(std::function<void()> read_only_fn)
-    {
-        //Copy is needed as filename WILL get trashed during the rest of the run
-        uToB->write("/freeze_state","");
-
-        std::list<const char *> fico;
-        int tries = 0;
-        while(tries++ < 10000) {
-            if(!bToU->hasNext()) {
-                usleep(500);
-                continue;
-            }
-            const char *msg = bToU->read();
-            if(!strcmp("/state_frozen", msg))
-                break;
-            size_t bytes = rtosc_message_length(msg, bToU->buffer_size());
-            char *save_buf = new char[bytes];
-            memcpy(save_buf, msg, bytes);
-            fico.push_back(save_buf);
-        }
-
-        assert(tries < 10000);//if this happens, the backend must be dead
-
-        std::atomic_thread_fence(std::memory_order_acquire);
-
-        //Now it is safe to do any read only operation
-        read_only_fn();
-
-        //Now to resume normal operations
-        uToB->write("/thaw_state","");
-        for(auto x:fico) {
-            uToB->raw_write(x);
-            delete [] x;
-        }
-    }
 
+    //Apply function while parameters are write locked
+    void doReadOnlyOp(std::function<void()> read_only_fn);
 
     void saveMaster(const char *filename)
     {
@@ -493,12 +437,17 @@ public:
             return;
         assert(actual_load[npart] <= pending_load[npart]);
 
-        auto alloc = std::async(std::launch::async, 
-                [master,filename,this,npart](){Part *p = new Part(*master->memory, &master->microtonal, master->fft);
+        auto alloc = std::async(std::launch::async,
+                [master,filename,this,npart](){
+                Part *p = new Part(*master->memory, &master->microtonal, master->fft);
                 if(p->loadXMLinstrument(filename))
                 fprintf(stderr, "FAILED TO LOAD PART!!\n");
 
-                p->applyparameters([this,npart]{printf("%d vs %d\n", (int)actual_load[npart], (int)pending_load[npart]);return actual_load[npart] != pending_load[npart];});
+                auto isLateLoad = [this,npart]{
+                return actual_load[npart] != pending_load[npart];
+                };
+
+                p->applyparameters(isLateLoad);
                 return p;});
 
         //Load the part
@@ -514,7 +463,6 @@ public:
 
         //Give it to the backend and wait for the old part to return for
         //deallocation
-        //printf("writing something to the location called '%s'\n", msg);
         uToB->write("/load-part", "ib", npart, sizeof(Part*), &p);
         osc->damage(("/part"+to_s(npart)+"/").c_str());
     }
@@ -535,59 +483,12 @@ public:
 
         //Give it to the backend and wait for the old part to return for
         //deallocation
-        //printf("writing something to the location called '%s'\n", msg);
         uToB->write("/load-master", "b", sizeof(Master*), &m);
     }
 
+    //If currently broadcasting messages
     bool broadcast = false;
-
-    void bToUhandle(const char *rtmsg)
-    {
-        printf(".");fflush(stdout);//return: got a '%s'\n", rtmsg);
-        if(!strcmp(rtmsg, "/echo")
-                && !strcmp(rtosc_argument_string(rtmsg),"ss")
-                && !strcmp(rtosc_argument(rtmsg,0).s, "OSC_URL"))
-            curr_url = rtosc_argument(rtmsg,1).s;
-        else if(!strcmp(rtmsg, "/free")
-                && !strcmp(rtosc_argument_string(rtmsg),"sb")) {
-            deallocate(rtosc_argument(rtmsg, 0).s, *((void**)rtosc_argument(rtmsg, 1).b.data));
-        } else if(!strcmp(rtmsg, "/request-memory")) {
-            //Generate out more memory for the RT memory pool
-            //5MBi chunk
-            size_t N  = 5*1024*1024;
-            void *mem = malloc(N);
-            uToB->write("/add-rt-memory", "bi", sizeof(void*), &mem, N);
-        } else if(!strcmp(rtmsg, "/setprogram")
-                && !strcmp(rtosc_argument_string(rtmsg),"cc")) {
-            loadPart(rtosc_argument(rtmsg,0).i, master->bank.ins[rtosc_argument(rtmsg,1).i].filename.c_str(), master, osc);
-        } else if(!strcmp(rtmsg, "/broadcast")) {
-            broadcast = true;
-        } else if(broadcast) {
-            broadcast = false;
-            cb(ui, rtmsg);
-            if(curr_url != "GUI") {
-                lo_message msg  = lo_message_deserialise((void*)rtmsg,
-                        rtosc_message_length(rtmsg, bToU->buffer_size()), NULL);
-
-                //Send to known url
-                if(!curr_url.empty()) {
-                    lo_address addr = lo_address_new_from_url(curr_url.c_str());
-                    lo_send_message(addr, rtmsg, msg);
-                }
-            }
-        } else if(curr_url == "GUI" || !strcmp(rtmsg, "/close-ui")) {
-            cb(ui, rtmsg);
-        } else{
-            lo_message msg  = lo_message_deserialise((void*)rtmsg,
-                    rtosc_message_length(rtmsg, bToU->buffer_size()), NULL);
-
-            //Send to known url
-            if(!curr_url.empty()) {
-                lo_address addr = lo_address_new_from_url(curr_url.c_str());
-                lo_send_message(addr, rtmsg, msg);
-            }
-        }
-    }
+    void bToUhandle(const char *rtmsg);
 
     void tick(void)
     {
@@ -616,132 +517,21 @@ public:
         return true;
     }
 
-    bool handleOscil(string path, const char *msg, void *v)
-    {
-        char buffer[1024];
-        memset(buffer, 0, sizeof(buffer));
-        DummyDataObj d(buffer, 1024, v, cb, ui, osc);
-        strcpy(buffer, path.c_str());
+    bool handleOscil(string path, const char *msg, void *v);
 
-        for(auto &p:OscilGen::ports.ports) {
-            if(strstr(p.name,msg) && strstr(p.metadata, "realtime") &&
-                    !strcmp("b", rtosc_argument_string(msg))) {
-                //printf("sending along packet '%s'...\n", msg);
-                return false;
-            }
-        }
+    // Handle an event with special cases
+    void handleMsg(const char *msg);
 
-        OscilGen::ports.dispatch(msg, d);
-        if(!d.matches) {
-            //fprintf(stderr, "%c[%d;%d;%dm", 0x1B, 1, 7 + 30, 0 + 40);
-            //fprintf(stderr, "Unknown location '%s%s'<%s>\n",
-            //        path.c_str(), msg, rtosc_argument_string(msg));
-            //fprintf(stderr, "%c[%d;%d;%dm", 0x1B, 0, 7 + 30, 0 + 40);
-        }
 
-        return true;
-    }
-
-    /* Should handle the following paths specially
-     * as they are all fundamentally non-realtime data
-     *
-     * BASE/part#/kititem#
-     * BASE/part#/kit#/adpars/voice#/oscil/\*
-     * BASE/part#/kit#/adpars/voice#/mod-oscil/\*
-     * BASE/part#/kit#/padpars/prepare
-     * BASE/part#/kit#/padpars/oscil/\*
-     */
-    void handleMsg(const char *msg)
-    {
-        assert(!strstr(msg,"free"));
-        assert(msg && *msg && rindex(msg, '/')[1]);
-        //fprintf(stdout, "%c[%d;%d;%dm", 0x1B, 0, 6 + 30, 0 + 40);
-        //fprintf(stdout, "middleware: '%s'\n", msg);
-        //fprintf(stdout, "%c[%d;%d;%dm", 0x1B, 0, 7 + 30, 0 + 40);
-        const char *last_path = rindex(msg, '/');
-        if(!last_path)
-            return;
-
-
-        //printf("watching '%s' go by\n", msg);
-        //Get the object resource locator
-        string obj_rl(msg, last_path+1);
-
-        if(!strcmp(msg, "/refresh_bank") && !strcmp(rtosc_argument_string(msg), "i")) {
-            refreshBankView(master->bank, rtosc_argument(msg,0).i, osc);
-        } else if(!strcmp(msg, "/bank-list") && !strcmp(rtosc_argument_string(msg), "")) {
-            bankList(master->bank, osc);
-        } else if(!strcmp(msg, "/rescanforbanks") && !strcmp(rtosc_argument_string(msg), "")) {
-            rescanForBanks(master->bank, osc);
-        } else if(!strcmp(msg, "/loadbank") && !strcmp(rtosc_argument_string(msg), "i")) {
-            loadBank(master->bank, rtosc_argument(msg, 0).i, osc);
-        } else if(!strcmp(msg, "/loadbank") && !strcmp(rtosc_argument_string(msg), "")) {
-            bankPos(master->bank, osc);
-        } else if(obj_store.has(obj_rl)) {
-            //try some over simplified pattern matching
-            if(strstr(msg, "oscil/")) {
-                if(!handleOscil(obj_rl, last_path+1, obj_store.get(obj_rl)))
-                    uToB->raw_write(msg);
-            //else if(strstr(obj_rl.c_str(), "kititem"))
-            //    handleKitItem(obj_rl, objmap[obj_rl],atoi(rindex(msg,'m')+1),rtosc_argument(msg,0).T);
-            } else if(strstr(msg, "padpars/prepare"))
-                preparePadSynth(obj_rl,(PADnoteParameters *) obj_store.get(obj_rl));
-            else if(strstr(msg, "padpars")) {
-                if(!handlePAD(obj_rl, last_path+1, obj_store.get(obj_rl)))
-                    uToB->raw_write(msg);
-            } else //just forward the message
-                uToB->raw_write(msg);
-        } else if(strstr(msg, "/save_xmz") && !strcmp(rtosc_argument_string(msg), "s")) {
-            saveMaster(rtosc_argument(msg,0).s);
-        } else if(strstr(msg, "/save_xiz") && !strcmp(rtosc_argument_string(msg), "is")) {
-            savePart(rtosc_argument(msg,0).i,rtosc_argument(msg,1).s);
-        } else if(strstr(msg, "/load_xmz") && !strcmp(rtosc_argument_string(msg), "s")) {
-            loadMaster(rtosc_argument(msg,0).s);
-        } else if(!strcmp(msg, "/load_xiz") && !strcmp(rtosc_argument_string(msg), "is")) {
-            pending_load[rtosc_argument(msg,0).i]++;
-            loadPart(rtosc_argument(msg,0).i, rtosc_argument(msg,1).s, master, osc);
-        } else if(strstr(msg, "load-part") && !strcmp(rtosc_argument_string(msg), "is")) {
-            pending_load[rtosc_argument(msg,0).i]++;
-            loadPart(rtosc_argument(msg,0).i, rtosc_argument(msg,1).s, master, osc);
-        } else
-            uToB->raw_write(msg);
-    }
-
-
-    void write(const char *path, const char *args, ...)
-    {
-        //We have a free buffer in the threadlink, so use it
-        va_list va;
-        va_start(va, args);
-        write(path, args, va);
-    }
-
-    void write(const char *path, const char *args, va_list va)
-    {
-        //printf("is that a '%s' I see there?\n", path);
-        char *buffer = uToB->buffer();
-        unsigned len = uToB->buffer_size();
-        bool success = rtosc_vmessage(buffer, len, path, args, va);
-        //printf("working on '%s':'%s'\n",path, args);
-
-        if(success)
-            handleMsg(buffer);
-        else
-            warnx("Failed to write message to '%s'", path);
-    }
+    void write(const char *path, const char *args, ...);
+    void write(const char *path, const char *args, va_list va);
 
-    //Ports
-    //oscil - base path, kit, voice, name
-    //pad   - base path, kit
 
-    //Actions that may be done on these objects
-    //Oscilgen almost all parameters can be safely set
-    //Padnote can have anything set on its oscilgen and a very small set of general
-    //parameters
-
-    //Provides a mapping for non-RT objects stored inside the backend
-    /**
-     * TODO These pointers may invalidate when part/master is loaded via xml
+    /*
+     * Provides a mapping for non-RT objects stored inside the backend
+     * - Oscilgen almost all parameters can be safely set
+     * - Padnote can have anything set on its oscilgen and a very small set
+     *   of general parameters
      */
     NonRtObjStore obj_store;
 
@@ -752,27 +542,303 @@ public:
     //The ONLY means that any chunk of UI code should have for interacting with the
     //backend
     Fl_Osc_Interface *osc;
-
-    //Information to keep track of which kit parts are active
-    //Two classes of events are observed
-    //
-    //1. When a kit transitions from inactive to active then a set of parameter
-    //   data must be allocated (no deallocation ever occurs here)
-    //2. When a part is rebuilt from a pointer swap all kit activity is set to
-    //   their new values
+    //Synth Engine Parameters
     ParamStore kits;
 
+    //Callback When Waiting on async events
     void(*idle)(void);
+    //General UI callback
     cb_t cb;
+    //UI handle
     void *ui;
 
     std::atomic_int pending_load[NUM_MIDI_PARTS];
     std::atomic_int actual_load[NUM_MIDI_PARTS];
 };
 
-/**
- * Interface to the middleware layer via osc packets
+MiddleWareImpl::MiddleWareImpl(void)
+{
+    server = lo_server_new_with_proto(NULL, LO_UDP, liblo_error_cb);
+    lo_server_add_method(server, NULL, NULL, handler_function, NULL);
+    fprintf(stderr, "lo server running on %d\n", lo_server_get_port(server));
+
+    {
+        std::string tmp_nam = get_tmp_nam();
+        if(0 == access(tmp_nam.c_str(), F_OK)) {
+            fprintf(stderr, "Error: Cannot overwrite file %s. "
+                    "You should probably remove it.", tmp_nam.c_str());
+            exit(EXIT_FAILURE);
+        }
+        FILE* tmp_fp = fopen(tmp_nam.c_str(), "w");
+        if(!tmp_fp)
+            fprintf(stderr, "Warning: could not create new file %s.\n",
+                    tmp_nam.c_str());
+        else
+            fprintf(tmp_fp, "%u", (unsigned)lo_server_get_port(server));
+        fclose(tmp_fp);
+    }
+
+    //dummy callback for starters
+    cb = [](void*, const char*){};
+    idle = 0;
+
+    master = new Master();
+    osc    = genOscInterface(this);
+
+    //Grab objects of interest from master
+    obj_store.extractMaster(master);
+
+    //Null out Load IDs
+    for(int i=0; i < NUM_MIDI_PARTS; ++i) {
+        pending_load[i] = 0;
+        actual_load[i] = 0;
+    }
+}
+MiddleWareImpl::~MiddleWareImpl(void)
+{
+    remove(get_tmp_nam().c_str());
+
+    warnMemoryLeaks();
+
+    delete master;
+    delete osc;
+}
+
+/** Threading When Saving
+ *  ----------------------
+ *
+ * Procedure Middleware:
+ *   1) Middleware sends /freeze_state to backend
+ *   2) Middleware waits on /state_frozen from backend
+ *      All intervening commands are held for out of order execution
+ *   3) Aquire memory
+ *      At this time by the memory barrier we are guarenteed that all old
+ *      writes are done and assuming the freezing logic is sound, then it is
+ *      impossible for any other parameter to change at this time
+ *   3) Middleware performs saving operation
+ *   4) Middleware sends /thaw_state to backend
+ *   5) Restore in order execution
+ *
+ * Procedure Backend:
+ *   1) Observe /freeze_state and disable all mutating events (MIDI CC)
+ *   2) Run a memory release to ensure that all writes are complete
+ *   3) Send /state_frozen to Middleware
+ *   time...
+ *   4) Observe /thaw_state and resume normal processing
+ */
+
+void MiddleWareImpl::doReadOnlyOp(std::function<void()> read_only_fn)
+{
+    //Copy is needed as filename WILL get trashed during the rest of the run
+    uToB->write("/freeze_state","");
+
+    std::list<const char *> fico;
+    int tries = 0;
+    while(tries++ < 10000) {
+        if(!bToU->hasNext()) {
+            usleep(500);
+            continue;
+        }
+        const char *msg = bToU->read();
+        if(!strcmp("/state_frozen", msg))
+            break;
+        size_t bytes = rtosc_message_length(msg, bToU->buffer_size());
+        char *save_buf = new char[bytes];
+        memcpy(save_buf, msg, bytes);
+        fico.push_back(save_buf);
+    }
+
+    assert(tries < 10000);//if this happens, the backend must be dead
+
+    std::atomic_thread_fence(std::memory_order_acquire);
+
+    //Now it is safe to do any read only operation
+    read_only_fn();
+
+    //Now to resume normal operations
+    uToB->write("/thaw_state","");
+    for(auto x:fico) {
+        uToB->raw_write(x);
+        delete [] x;
+    }
+}
+
+void MiddleWareImpl::bToUhandle(const char *rtmsg)
+{
+    //Dump Incomming Events For Debugging
+    if(strcmp(rtmsg, "/vu-meter") && true) {
+        fprintf(stdout, "%c[%d;%d;%dm", 0x1B, 0, 1 + 30, 0 + 40);
+        fprintf(stdout, "frontend: '%s'<%s>\n", rtmsg,
+                rtosc_argument_string(rtmsg));
+        fprintf(stdout, "%c[%d;%d;%dm", 0x1B, 0, 7 + 30, 0 + 40);
+    }
+
+    //Activity dot
+    printf(".");fflush(stdout);
+
+    if(!strcmp(rtmsg, "/echo")
+            && !strcmp(rtosc_argument_string(rtmsg),"ss")
+            && !strcmp(rtosc_argument(rtmsg,0).s, "OSC_URL"))
+        curr_url = rtosc_argument(rtmsg,1).s;
+    else if(!strcmp(rtmsg, "/free")
+            && !strcmp(rtosc_argument_string(rtmsg),"sb")) {
+        deallocate(rtosc_argument(rtmsg, 0).s, *((void**)rtosc_argument(rtmsg, 1).b.data));
+    } else if(!strcmp(rtmsg, "/request-memory")) {
+        //Generate out more memory for the RT memory pool
+        //5MBi chunk
+        size_t N  = 5*1024*1024;
+        void *mem = malloc(N);
+        uToB->write("/add-rt-memory", "bi", sizeof(void*), &mem, N);
+    } else if(!strcmp(rtmsg, "/setprogram")
+            && !strcmp(rtosc_argument_string(rtmsg),"cc")) {
+        loadPart(rtosc_argument(rtmsg,0).i, master->bank.ins[rtosc_argument(rtmsg,1).i].filename.c_str(), master, osc);
+    } else if(!strcmp(rtmsg, "/broadcast")) {
+        broadcast = true;
+    } else if(broadcast) {
+        broadcast = false;
+        cb(ui, rtmsg);
+        if(curr_url != "GUI") {
+            lo_message msg  = lo_message_deserialise((void*)rtmsg,
+                    rtosc_message_length(rtmsg, bToU->buffer_size()), NULL);
+
+            //Send to known url
+            if(!curr_url.empty()) {
+                lo_address addr = lo_address_new_from_url(curr_url.c_str());
+                lo_send_message(addr, rtmsg, msg);
+            }
+        }
+    } else if(curr_url == "GUI" || !strcmp(rtmsg, "/close-ui")) {
+        cb(ui, rtmsg);
+    } else{
+        lo_message msg  = lo_message_deserialise((void*)rtmsg,
+                rtosc_message_length(rtmsg, bToU->buffer_size()), NULL);
+
+        //Send to known url
+        if(!curr_url.empty()) {
+            lo_address addr = lo_address_new_from_url(curr_url.c_str());
+            lo_send_message(addr, rtmsg, msg);
+        }
+    }
+}
+
+bool MiddleWareImpl::handleOscil(string path, const char *msg, void *v)
+{
+    char buffer[1024];
+    memset(buffer, 0, sizeof(buffer));
+    DummyDataObj d(buffer, 1024, v, cb, ui, osc);
+    strcpy(buffer, path.c_str());
+
+    for(auto &p:OscilGen::ports.ports) {
+        if(strstr(p.name,msg) && strstr(p.metadata, "realtime") &&
+                !strcmp("b", rtosc_argument_string(msg))) {
+            //printf("sending along packet '%s'...\n", msg);
+            return false;
+        }
+    }
+
+    OscilGen::ports.dispatch(msg, d);
+    if(!d.matches) {
+        //fprintf(stderr, "%c[%d;%d;%dm", 0x1B, 1, 7 + 30, 0 + 40);
+        //fprintf(stderr, "Unknown location '%s%s'<%s>\n",
+        //        path.c_str(), msg, rtosc_argument_string(msg));
+        //fprintf(stderr, "%c[%d;%d;%dm", 0x1B, 0, 7 + 30, 0 + 40);
+    }
+
+    return true;
+}
+
+
+/* BASE/part#/kititem#
+ * BASE/part#/kit#/adpars/voice#/oscil/\*
+ * BASE/part#/kit#/adpars/voice#/mod-oscil/\*
+ * BASE/part#/kit#/padpars/prepare
+ * BASE/part#/kit#/padpars/oscil/\*
  */
+void MiddleWareImpl::handleMsg(const char *msg)
+{
+    assert(!strstr(msg,"free"));
+    assert(msg && *msg && rindex(msg, '/')[1]);
+    //fprintf(stdout, "%c[%d;%d;%dm", 0x1B, 0, 6 + 30, 0 + 40);
+    //fprintf(stdout, "middleware: '%s'\n", msg);
+    //fprintf(stdout, "%c[%d;%d;%dm", 0x1B, 0, 7 + 30, 0 + 40);
+    const char *last_path = rindex(msg, '/');
+    if(!last_path)
+        return;
+
+
+    //printf("watching '%s' go by\n", msg);
+    //Get the object resource locator
+    string obj_rl(msg, last_path+1);
+
+    if(!strcmp(msg, "/refresh_bank") && !strcmp(rtosc_argument_string(msg), "i")) {
+        refreshBankView(master->bank, rtosc_argument(msg,0).i, osc);
+    } else if(!strcmp(msg, "/bank-list") && !strcmp(rtosc_argument_string(msg), "")) {
+        bankList(master->bank, osc);
+    } else if(!strcmp(msg, "/rescanforbanks") && !strcmp(rtosc_argument_string(msg), "")) {
+        rescanForBanks(master->bank, osc);
+    } else if(!strcmp(msg, "/loadbank") && !strcmp(rtosc_argument_string(msg), "i")) {
+        loadBank(master->bank, rtosc_argument(msg, 0).i, osc);
+    } else if(!strcmp(msg, "/loadbank") && !strcmp(rtosc_argument_string(msg), "")) {
+        bankPos(master->bank, osc);
+    } else if(obj_store.has(obj_rl)) {
+        //try some over simplified pattern matching
+        if(strstr(msg, "oscil/")) {
+            if(!handleOscil(obj_rl, last_path+1, obj_store.get(obj_rl)))
+                uToB->raw_write(msg);
+            //else if(strstr(obj_rl.c_str(), "kititem"))
+            //    handleKitItem(obj_rl, objmap[obj_rl],atoi(rindex(msg,'m')+1),rtosc_argument(msg,0).T);
+        } else if(strstr(msg, "padpars/prepare"))
+            preparePadSynth(obj_rl,(PADnoteParameters *) obj_store.get(obj_rl));
+        else if(strstr(msg, "padpars")) {
+            if(!handlePAD(obj_rl, last_path+1, obj_store.get(obj_rl)))
+                uToB->raw_write(msg);
+        } else //just forward the message
+            uToB->raw_write(msg);
+    } else if(strstr(msg, "/save_xmz") && !strcmp(rtosc_argument_string(msg), "s")) {
+        saveMaster(rtosc_argument(msg,0).s);
+    } else if(strstr(msg, "/save_xiz") && !strcmp(rtosc_argument_string(msg), "is")) {
+        savePart(rtosc_argument(msg,0).i,rtosc_argument(msg,1).s);
+    } else if(strstr(msg, "/load_xmz") && !strcmp(rtosc_argument_string(msg), "s")) {
+        loadMaster(rtosc_argument(msg,0).s);
+    } else if(!strcmp(msg, "/load_xiz") && !strcmp(rtosc_argument_string(msg), "is")) {
+        pending_load[rtosc_argument(msg,0).i]++;
+        loadPart(rtosc_argument(msg,0).i, rtosc_argument(msg,1).s, master, osc);
+    } else if(strstr(msg, "load-part") && !strcmp(rtosc_argument_string(msg), "is")) {
+        pending_load[rtosc_argument(msg,0).i]++;
+        loadPart(rtosc_argument(msg,0).i, rtosc_argument(msg,1).s, master, osc);
+    } else
+        uToB->raw_write(msg);
+}
+
+void MiddleWareImpl::write(const char *path, const char *args, ...)
+{
+    //We have a free buffer in the threadlink, so use it
+    va_list va;
+    va_start(va, args);
+    write(path, args, va);
+}
+
+void MiddleWareImpl::write(const char *path, const char *args, va_list va)
+{
+    //printf("is that a '%s' I see there?\n", path);
+    char *buffer = uToB->buffer();
+    unsigned len = uToB->buffer_size();
+    bool success = rtosc_vmessage(buffer, len, path, args, va);
+    //printf("working on '%s':'%s'\n",path, args);
+
+    if(success)
+        handleMsg(buffer);
+    else
+        warnx("Failed to write message to '%s'", path);
+}
+
+/******************************************************************************
+ *    OSC Interface For User Interface                                        *
+ *                                                                            *
+ *    This is a largely out of date section of code                           *
+ *    Most type specific write methods are no longer used                     *
+ *    See UI/Fl_Osc_* to see what is actually used in this interface          *
+ ******************************************************************************/
 class UI_Interface:public Fl_Osc_Interface
 {
     public:
@@ -973,9 +1039,11 @@ Fl_Osc_Interface *genOscInterface(class MiddleWareImpl *impl)
     return new UI_Interface(impl);
 }
 
-//stubs
-MiddleWare::MiddleWare(void)
-    :impl(new MiddleWareImpl())
+/******************************************************************************
+ *                         MidleWare Forwarding Stubs                         *
+ ******************************************************************************/
+    MiddleWare::MiddleWare(void)
+:impl(new MiddleWareImpl())
 {}
 MiddleWare::~MiddleWare(void)
 {
diff --git a/src/Misc/MiddleWare.h b/src/Misc/MiddleWare.h
index 77e174f0..a6e31ce6 100644
--- a/src/Misc/MiddleWare.h
+++ b/src/Misc/MiddleWare.h
@@ -6,15 +6,18 @@ class MiddleWare
     public:
         MiddleWare(void);
         ~MiddleWare(void);
-        //return internal master pointer
+        //returns internal master pointer
         class Master *spawnMaster(void);
+        //return  UI interface
         class Fl_Osc_Interface *spawnUiApi(void);
+        //Set callback to push UI events to
         void setUiCallback(void(*cb)(void*,const char *),void *ui);
+        //Set callback to run while busy
         void setIdleCallback(void(*cb)(void));
+        //Handle events
         void tick(void);
+        //Indicate that a program will be loaded on a known part
         void pendingSetProgram(int part);
-
-        static void preparePadSynth(const char *, class PADnoteParameters *){};
     private:
         class MiddleWareImpl *impl;
 };
-- 
2.47.0

