From 821fd0bf5312f32889643ffbdfdf8deecafb19c7 Mon Sep 17 00:00:00 2001
From: fundamental <mark.d.mccurry@gmail.com>
Date: Thu, 13 Feb 2014 16:36:02 -0500
Subject: [PATCH 0146/1936] Enable Lockless Saving XMZ Files

While this code isn't going to make any thread error detection tool too happy,
there are now memory barriers in place to freeze the backend and propagate any
pending changes to whatever coherency model is needed to ensure that the
middleware is able to grab the parameters safely from memory without a copy.
This general approach shall be extended to the cases of the parameters
responsible for Part, ADnote, SUBnote, PADnote, and perhaps ADnoteVoice.

The oddest part of this commit would have to be the fire in order complete
(slightly) out of order buffer needed to ensure that no events were lost on a
frozen state, but now that it seems to be sorted, doing this operation for other
structures should be very easy.

- Add code needed to transition backend into parameter readonly state
- Add handler for saving xmz files
---
 src/Misc/Master.cpp     |  17 ++++-
 src/Misc/Master.h       |   2 +
 src/Misc/MiddleWare.cpp | 147 ++++++++++++++++++++++++++++++----------
 3 files changed, 126 insertions(+), 40 deletions(-)

diff --git a/src/Misc/Master.cpp b/src/Misc/Master.cpp
index d328df13..26311a95 100644
--- a/src/Misc/Master.cpp
+++ b/src/Misc/Master.cpp
@@ -39,6 +39,7 @@
 #include <iostream>
 #include <algorithm>
 #include <cmath>
+#include <atomic>
 
 #include <unistd.h>
 
@@ -95,8 +96,16 @@ static Ports localports = {
         [](const char *m,RtData &d){
             Master *M =  (Master*)d.obj;
             M->setController(rtosc_argument(m,0).i,rtosc_argument(m,1).i,rtosc_argument(m,2).i);}},
-
-
+    {"freeze_state:", rDoc("Internal Read-only Mode"), 0,
+        [](const char *,RtData &d) {
+            Master *M =  (Master*)d.obj;
+            std::atomic_thread_fence(std::memory_order_release);
+            M->frozenState = true;
+            d.reply("/state_frozen");}},
+    {"thaw_state:", rDoc("Internal Read-only Mode"), 0,
+        [](const char *,RtData &d) {
+            Master *M =  (Master*)d.obj;
+            M->frozenState = false;}},
     {"register:iis", rDoc("MIDI Mapping Registration"), 0,
         [](const char *m,RtData &d){
             Master *M =  (Master*)d.obj;
@@ -157,7 +166,7 @@ vuData::vuData(void)
 {}
 
 Master::Master()
-:midi(Master::ports)
+:midi(Master::ports), frozenState(false)
 {
     the_master = this;
     swaplr = 0;
@@ -280,6 +289,8 @@ void Master::polyphonicAftertouch(char chan, char note, char velocity)
  */
 void Master::setController(char chan, int type, int par)
 {
+    if(frozenState)
+        return;
     midi.process(chan,type,par);
     if((type == C_dataentryhi) || (type == C_dataentrylo)
        || (type == C_nrpnhi) || (type == C_nrpnlo)) { //Process RPN and NRPN by the Master (ignore the chan)
diff --git a/src/Misc/Master.h b/src/Misc/Master.h
index 6eac516d..6dc9e578 100644
--- a/src/Misc/Master.h
+++ b/src/Misc/Master.h
@@ -157,6 +157,8 @@ class Master
         vuData vu;
 
         rtosc::MidiTable midi;//<1024,64>
+
+        bool   frozenState;//read-only parameters for threadsafe actions
     private:
         bool   nullRun;
         float  sysefxvol[NUM_SYS_EFX][NUM_MIDI_PARTS];
diff --git a/src/Misc/MiddleWare.cpp b/src/Misc/MiddleWare.cpp
index b078fd4c..b02f42d4 100644
--- a/src/Misc/MiddleWare.cpp
+++ b/src/Misc/MiddleWare.cpp
@@ -22,6 +22,7 @@
 #include "../Effects/EffectMgr.h"
 
 #include <string>
+#include <atomic>
 
 #include <err.h>
 
@@ -148,9 +149,9 @@ void deallocate(const char *str, void *v)
  * - Fetches liblo messages and forward them to the backend
  * - Grabs backend messages and distributes them to the frontends
  */
-void osc_check(cb_t cb, void *ui)
-{
-}
+//void osc_check(cb_t cb, void *ui)
+//{
+//}
 
 
 
@@ -344,6 +345,70 @@ struct MiddleWareImpl
     }
 
     void warnMemoryLeaks(void);
+        
+    /** Threading When Saving
+     *  ----------------------
+     *
+     * Procedure Middleware: 
+     *   1) Middleware sends /freeze_state to backend
+     *   2) Middleware waits on /state_frozen from backend
+     *      All intervening commands are held for out of order execution
+     *   3) Aquire memory
+     *      At this time by the memory barrier we are guarenteed that all old
+     *      writes are done and assuming the freezing logic is sound, then it is
+     *      impossible for any other parameter to change at this time
+     *   3) Middleware performs saving operation
+     *   4) Middleware sends /thaw_state to backend
+     *   5) Restore in order execution
+     *
+     * Procedure Backend:
+     *   1) Observe /freeze_state and disable all mutating events (MIDI CC)
+     *   2) Run a memory release to ensure that all writes are complete
+     *   3) Send /state_frozen to Middleware
+     *   time...
+     *   4) Observe /thaw_state and resume normal processing
+     */
+
+
+    void saveMaster(const char *filename)
+    {
+        //Copy is needed as filename WILL get trashed during the rest of the run
+        std::string fname = filename;
+        printf("saving master('%s')\n", filename);
+        uToB->write("/freeze_state","");
+
+        std::list<const char *> fico;
+        int tries = 0;
+        while(tries++ < 10000) {
+            if(!bToU->hasNext()) {
+                usleep(500);
+                continue;
+            }
+            const char *msg = bToU->read();
+            if(!strcmp("/state_frozen", msg))
+                break;
+            size_t bytes = rtosc_message_length(msg, bToU->buffer_size());
+            char *save_buf = new char[bytes];
+            memcpy(save_buf, msg, bytes);
+            fico.push_back(save_buf);
+        }
+
+        assert(tries < 10000);//if this happens, the backend must be dead
+
+        std::atomic_thread_fence(std::memory_order_acquire);
+
+        //Now it is safe to do any read only operation
+
+        int res = master->saveXML(fname.c_str());
+        printf("results: '%s' '%d'\n",fname.c_str(), res);
+        
+        //Now to resume normal operations
+        uToB->write("/thaw_state","");
+        for(auto x:fico) {
+            uToB->raw_write(x);
+            delete [] x;
+        }
+    }
 
     void loadPart(int npart, const char *filename, Master *master, Fl_Osc_Interface *osc)
     {
@@ -412,40 +477,26 @@ struct MiddleWareImpl
     }
 
     bool broadcast = false;
-    void tick(void)
+
+    void bToUhandle(const char *rtmsg)
     {
-        lo_server_recv_noblock(server, 0);
-        while(bToU->hasNext()) {
-            const char *rtmsg = bToU->read();
-            //printf("return: got a '%s'\n", rtmsg);
-            if(!strcmp(rtmsg, "/echo")
-                    && !strcmp(rtosc_argument_string(rtmsg),"ss")
-                    && !strcmp(rtosc_argument(rtmsg,0).s, "OSC_URL"))
-                curr_url = rtosc_argument(rtmsg,1).s;
-            else if(!strcmp(rtmsg, "/free")
-                    && !strcmp(rtosc_argument_string(rtmsg),"sb")) {
-                deallocate(rtosc_argument(rtmsg, 0).s, *((void**)rtosc_argument(rtmsg, 1).b.data));
-            } else if(!strcmp(rtmsg, "/setprogram")
-                    && !strcmp(rtosc_argument_string(rtmsg),"cc")) {
-                loadPart(rtosc_argument(rtmsg,0).i, master->bank.ins[rtosc_argument(rtmsg,1).i].filename.c_str(), master, osc);
-            } else if(!strcmp(rtmsg, "/broadcast")) {
-                broadcast = true;
-            } else if(broadcast) {
-                broadcast = false;
-                cb(ui, rtmsg);
-                if(curr_url != "GUI") {
-                    lo_message msg  = lo_message_deserialise((void*)rtmsg,
-                            rtosc_message_length(rtmsg, bToU->buffer_size()), NULL);
-
-                    //Send to known url
-                    if(!curr_url.empty()) {
-                        lo_address addr = lo_address_new_from_url(curr_url.c_str());
-                        lo_send_message(addr, rtmsg, msg);
-                    }
-                }
-            } else if(curr_url == "GUI") {
-                cb(ui, rtmsg); //GUI::raiseUi(gui, bToU->read());
-            } else{
+        //printf("return: got a '%s'\n", rtmsg);
+        if(!strcmp(rtmsg, "/echo")
+                && !strcmp(rtosc_argument_string(rtmsg),"ss")
+                && !strcmp(rtosc_argument(rtmsg,0).s, "OSC_URL"))
+            curr_url = rtosc_argument(rtmsg,1).s;
+        else if(!strcmp(rtmsg, "/free")
+                && !strcmp(rtosc_argument_string(rtmsg),"sb")) {
+            deallocate(rtosc_argument(rtmsg, 0).s, *((void**)rtosc_argument(rtmsg, 1).b.data));
+        } else if(!strcmp(rtmsg, "/setprogram")
+                && !strcmp(rtosc_argument_string(rtmsg),"cc")) {
+            loadPart(rtosc_argument(rtmsg,0).i, master->bank.ins[rtosc_argument(rtmsg,1).i].filename.c_str(), master, osc);
+        } else if(!strcmp(rtmsg, "/broadcast")) {
+            broadcast = true;
+        } else if(broadcast) {
+            broadcast = false;
+            cb(ui, rtmsg);
+            if(curr_url != "GUI") {
                 lo_message msg  = lo_message_deserialise((void*)rtmsg,
                         rtosc_message_length(rtmsg, bToU->buffer_size()), NULL);
 
@@ -455,6 +506,26 @@ struct MiddleWareImpl
                     lo_send_message(addr, rtmsg, msg);
                 }
             }
+        } else if(curr_url == "GUI") {
+            cb(ui, rtmsg); //GUI::raiseUi(gui, bToU->read());
+        } else{
+            lo_message msg  = lo_message_deserialise((void*)rtmsg,
+                    rtosc_message_length(rtmsg, bToU->buffer_size()), NULL);
+
+            //Send to known url
+            if(!curr_url.empty()) {
+                lo_address addr = lo_address_new_from_url(curr_url.c_str());
+                lo_send_message(addr, rtmsg, msg);
+            }
+        }
+    }
+
+    void tick(void)
+    {
+        lo_server_recv_noblock(server, 0);
+        while(bToU->hasNext()) {
+            const char *rtmsg = bToU->read();
+            bToUhandle(rtmsg);
         }
     }
 
@@ -559,7 +630,9 @@ struct MiddleWareImpl
                     uToB->raw_write(msg);
             } else //just forward the message
                 uToB->raw_write(msg);
-        } else if(strstr(msg, "load_xmz") && !strcmp(rtosc_argument_string(msg), "s")) {
+        } else if(strstr(msg, "/save_xmz") && !strcmp(rtosc_argument_string(msg), "s")) {
+            saveMaster(rtosc_argument(msg,0).s);
+        } else if(strstr(msg, "/load_xmz") && !strcmp(rtosc_argument_string(msg), "s")) {
             loadMaster(rtosc_argument(msg,0).s);
         } else if(strstr(msg, "load-part") && !strcmp(rtosc_argument_string(msg), "is"))
             loadPart(rtosc_argument(msg,0).i, rtosc_argument(msg,1).s, master, osc);
-- 
2.47.0

