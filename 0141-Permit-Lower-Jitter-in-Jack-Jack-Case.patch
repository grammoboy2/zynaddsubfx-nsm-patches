From 7a44fad08a16616c0af24ca11a27afe12c977387 Mon Sep 17 00:00:00 2001
From: fundamental <mark.d.mccurry@gmail.com>
Date: Thu, 23 Jan 2014 14:12:36 -0500
Subject: [PATCH 0141/1936] Permit Lower Jitter in Jack-Jack Case

When -IJack -OJack is used and an internal buffersize
smaller than jacks is used, midi messages will be applied to
the correct internal buffer.
This should *not* affect any other Nio combination.
---
 src/Nio/InMgr.cpp      | 18 ++++++++++++++++--
 src/Nio/InMgr.h        |  7 +++++--
 src/Nio/JackEngine.cpp |  5 +++++
 src/Nio/JackEngine.h   |  1 +
 src/Nio/OutMgr.cpp     | 27 +++++++++++++++------------
 src/Nio/SafeQueue.cpp  | 13 +++++++++++++
 src/Nio/SafeQueue.h    |  1 +
 7 files changed, 56 insertions(+), 16 deletions(-)

diff --git a/src/Nio/InMgr.cpp b/src/Nio/InMgr.cpp
index af8d63c8..b9db3fbd 100644
--- a/src/Nio/InMgr.cpp
+++ b/src/Nio/InMgr.cpp
@@ -31,7 +31,7 @@ ostream &operator<<(ostream &out, const MidiEvent &ev)
 }
 
 MidiEvent::MidiEvent()
-    :channel(0), type(0), num(0), value(0)
+    :channel(0), type(0), num(0), value(0), time(0)
 {}
 
 InMgr &InMgr::getInstance()
@@ -61,10 +61,17 @@ void InMgr::putEvent(MidiEvent ev)
         sem_post(&work);
 }
 
-void InMgr::flush()
+void InMgr::flush(unsigned frameStart, unsigned frameStop)
 {
     MidiEvent ev;
     while(!sem_trywait(&work)) {
+        queue.peak(ev);
+        if(ev.time < (int)frameStart || ev.time > (int)frameStop) {
+            //Back out of transaction
+            sem_post(&work);
+            //printf("%d vs [%d..%d]\n",ev.time, frameStart, frameStop);
+            break;
+        }
         queue.pop(ev);
         //cout << ev << endl;
 
@@ -93,6 +100,13 @@ void InMgr::flush()
     }
 }
 
+bool InMgr::empty(void) const
+{
+    int semvalue = 0;
+    sem_getvalue(&work, &semvalue);
+    return semvalue <= 0;
+}
+
 bool InMgr::setSource(string name)
 {
     MidiIn *src = getIn(name);
diff --git a/src/Nio/InMgr.h b/src/Nio/InMgr.h
index 03dcad07..b06bd37a 100644
--- a/src/Nio/InMgr.h
+++ b/src/Nio/InMgr.h
@@ -19,6 +19,7 @@ struct MidiEvent {
     int type;    //type=1 for note, type=2 for controller
     int num;     //note, controller or program number
     int value;   //velocity or controller value
+    int time;    //time offset of event (used only in jack->jack case at the moment)
 };
 
 //super simple class to manage the inputs
@@ -31,7 +32,9 @@ class InMgr
         void putEvent(MidiEvent ev);
 
         /**Flush the Midi Queue*/
-        void flush();
+        void flush(unsigned frameStart, unsigned frameStop);
+
+        bool empty() const;
 
         bool setSource(std::string name);
 
@@ -42,7 +45,7 @@ class InMgr
         InMgr();
         class MidiIn *getIn(std::string name);
         SafeQueue<MidiEvent> queue;
-        sem_t work;
+        mutable sem_t work;
         class MidiIn * current;
 
         /**the link to the rest of zyn*/
diff --git a/src/Nio/JackEngine.cpp b/src/Nio/JackEngine.cpp
index 8af0c387..134bd46c 100644
--- a/src/Nio/JackEngine.cpp
+++ b/src/Nio/JackEngine.cpp
@@ -45,6 +45,7 @@ JackEngine::JackEngine()
         audio.portBuffs[i] = NULL;
     }
     midi.inport = NULL;
+    midi.jack_sync = false;
 }
 
 bool JackEngine::connectServer(string server)
@@ -211,10 +212,12 @@ bool JackEngine::openAudio()
             else
                 cerr << "Warning, No outputs to autoconnect to" << endl;
         }
+        midi.jack_sync = true;
         return true;
     }
     else
         cerr << "Error, failed to register jack audio ports" << endl;
+    midi.jack_sync = false;
     return false;
 }
 
@@ -226,6 +229,7 @@ void JackEngine::stopAudio()
         if(NULL != port)
             jack_port_unregister(jackClient, port);
     }
+    midi.jack_sync = false;
     if(!getMidiEn())
         disconnectJack();
 }
@@ -352,6 +356,7 @@ void JackEngine::handleMidi(unsigned long frames)
         midi_data  = jack_midi_event.buffer;
         type       = midi_data[0] & 0xF0;
         ev.channel = midi_data[0] & 0x0F;
+        ev.time    = midi.jack_sync ? jack_midi_event.time : 0;
 
         switch(type) {
             case 0x80: /* note-off */
diff --git a/src/Nio/JackEngine.h b/src/Nio/JackEngine.h
index 1184ce84..705ff3ec 100644
--- a/src/Nio/JackEngine.h
+++ b/src/Nio/JackEngine.h
@@ -80,6 +80,7 @@ class JackEngine:public AudioOut, MidiIn
         } audio;
         struct midi {
             jack_port_t *inport;
+            bool         jack_sync;
         } midi;
 
         void handleMidi(unsigned long frames);
diff --git a/src/Nio/OutMgr.cpp b/src/Nio/OutMgr.cpp
index ea270bff..7fbe2417 100644
--- a/src/Nio/OutMgr.cpp
+++ b/src/Nio/OutMgr.cpp
@@ -45,28 +45,31 @@ OutMgr::~OutMgr()
 }
 
 /* Sequence of a tick
- * 1) lets see if we have any stuff to do via midi
- * 2) Lets do that stuff
- * 3) Lets see if the event queue has anything for us
- * 4) Lets empty that out
- * 5) Lets remove old/stale samples
- * 6) Lets see if we need to generate samples
- * 7) Lets generate some
- * 8) Lets return those samples to the primary and secondary outputs
- * 9) Lets wait for another tick
+ * 1) Lets remove old/stale samples
+ * 2) Apply appliciable midi events
+ * 3) Lets see if we need to generate samples
+ * 4) Lets generate some
+ * 5) Goto 2 if more are needed
+ * 6) Lets return those samples to the primary and secondary outputs
+ * 7) Lets wait for another tick
  */
 const Stereo<float *> OutMgr::tick(unsigned int frameSize)
 {
-    pthread_mutex_lock(&(master.mutex));
-    InMgr::getInstance().flush();
-    pthread_mutex_unlock(&(master.mutex));
+    InMgr &midi = InMgr::getInstance();
     //SysEv->execute();
     removeStaleSmps();
+    int i=0;
     while(frameSize > storedSmps()) {
+        if(!midi.empty()) {
+            pthread_mutex_lock(&(master.mutex));
+            midi.flush(i*synth->buffersize, (i+1)*synth->buffersize);
+            pthread_mutex_unlock(&(master.mutex));
+        }
         pthread_mutex_lock(&(master.mutex));
         master.AudioOut(outl, outr);
         pthread_mutex_unlock(&(master.mutex));
         addSmps(outl, outr);
+        i++;
     }
     stales = frameSize;
     return priBuf;
diff --git a/src/Nio/SafeQueue.cpp b/src/Nio/SafeQueue.cpp
index 734413c6..25b35890 100644
--- a/src/Nio/SafeQueue.cpp
+++ b/src/Nio/SafeQueue.cpp
@@ -55,6 +55,19 @@ int SafeQueue<T>::push(const T &in)
     return 0;
 }
 
+template<class T>
+int SafeQueue<T>::peak(T &out) const
+{
+    if(!rSpace())
+        return -1;
+
+    //ok, there is space to read
+    size_t r = (readPtr + 1) % bufSize;
+    out     = buffer[r];
+
+    return 0;
+}
+
 template<class T>
 int SafeQueue<T>::pop(T &out)
 {
diff --git a/src/Nio/SafeQueue.h b/src/Nio/SafeQueue.h
index 072a1e09..8b6b0693 100644
--- a/src/Nio/SafeQueue.h
+++ b/src/Nio/SafeQueue.h
@@ -21,6 +21,7 @@ class SafeQueue
         /**Returns 0 for normal
          * Returns -1 on error*/
         int push(const T &in);
+        int peak(T &out) const;
         int pop(T &out);
 
         //clears reading space
-- 
2.47.0

