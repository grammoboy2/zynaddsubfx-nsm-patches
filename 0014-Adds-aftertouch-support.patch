From f3946b60102baf97e8684d6f9f95e0ecad5f8fc8 Mon Sep 17 00:00:00 2001
From: fundamental <mark.d.mccurry@gmail.com>
Date: Thu, 31 May 2012 23:32:08 -0400
Subject: [PATCH 0014/1936] Adds aftertouch support

Integrates MIDI aftertouch support for normal, legato, and mono notes.

- Patch by Olaf Schulz
---
 AUTHORS.txt             |  1 +
 src/Misc/Master.cpp     | 16 +++++++++++++
 src/Misc/Master.h       |  1 +
 src/Misc/Part.cpp       | 52 +++++++++++++++++++++++++++++++++++++++++
 src/Misc/Part.h         |  3 +++
 src/Nio/AlsaEngine.cpp  |  8 +++++++
 src/Nio/InMgr.cpp       |  3 +++
 src/Nio/InMgr.h         |  4 +++-
 src/Nio/JackEngine.cpp  |  7 ++++++
 src/Nio/MidiIn.cpp      |  7 ++++++
 src/Synth/SynthNote.cpp |  7 ++++++
 src/Synth/SynthNote.h   | 10 ++++++++
 12 files changed, 118 insertions(+), 1 deletion(-)

diff --git a/AUTHORS.txt b/AUTHORS.txt
index 620adcb5..1ddccc12 100644
--- a/AUTHORS.txt
+++ b/AUTHORS.txt
@@ -21,5 +21,6 @@ Contributors:
         Hans Petter Selasky (OSS Midi, FreeBSD support, Bank UI bug fix)
         Damien Goutte-Gattat (Bank select midi support)
         Lieven Moors (Spike/Circle waveform)
+        Olaf Schulz (MIDI Aftertouch support)
         Jonathan Liles (NSM support)
 
diff --git a/src/Misc/Master.cpp b/src/Misc/Master.cpp
index 07434f5d..c6890806 100644
--- a/src/Misc/Master.cpp
+++ b/src/Misc/Master.cpp
@@ -156,6 +156,22 @@ void Master::noteOff(char chan, char note)
             part[npart]->NoteOff(note);
 }
 
+/*
+ * Pressure Messages (velocity=0 for NoteOff)
+ */
+void Master::polyphonicAftertouch(char chan, char note, char velocity)
+{
+    if(velocity) {
+        for(int npart = 0; npart < NUM_MIDI_PARTS; ++npart)
+            if(chan == part[npart]->Prcvchn)
+                if(part[npart]->Penabled)
+                    part[npart]->PolyphonicAftertouch(note, velocity, keyshift);
+
+    }
+    else
+        this->noteOff(chan, note);
+}
+
 /*
  * Controllers
  */
diff --git a/src/Misc/Master.h b/src/Misc/Master.h
index fc5065eb..cce999b3 100644
--- a/src/Misc/Master.h
+++ b/src/Misc/Master.h
@@ -91,6 +91,7 @@ class Master
         //Midi IN
         void noteOn(char chan, char note, char velocity);
         void noteOff(char chan, char note);
+        void polyphonicAftertouch(char chan, char note, char velocity);
         void setController(char chan, int type, int par);
         void setProgram(char chan, unsigned int pgm);
         //void NRPN...
diff --git a/src/Misc/Part.cpp b/src/Misc/Part.cpp
index b5bbbf54..b70387ee 100644
--- a/src/Misc/Part.cpp
+++ b/src/Misc/Part.cpp
@@ -645,6 +645,58 @@ void Part::NoteOff(unsigned char note) //relase the key
         }
 }
 
+void Part::PolyphonicAftertouch(unsigned char note,
+                                unsigned char velocity,
+                                int masterkeyshift)
+{
+    if(!Pnoteon || (note < Pminkey) || (note > Pmaxkey))
+        return;
+    if(Pdrummode)
+        return;
+
+    // MonoMem stuff:
+    if(!Ppolymode)   // if Poly is off
+
+        monomem[note].velocity = velocity;       // Store this note's velocity.
+
+
+    for(int i = 0; i < POLIPHONY; ++i)
+        if((partnote[i].note == note) && (partnote[i].status == KEY_PLAYING)) {
+            /* update velocity */
+            // compute the velocity offset
+            float vel =
+                VelF(velocity / 127.0f, Pvelsns) + (Pveloffs - 64.0f) / 64.0f;
+            vel = (vel < 0.0f) ? 0.0f : vel;
+            vel = (vel > 1.0f) ? 1.0f : vel;
+
+            if(!Pkitmode) { // "normal mode"
+                if(kit[0].Padenabled)
+                    partnote[i].kititem[0].adnote->setVelocity(vel);
+                if(kit[0].Psubenabled)
+                    partnote[i].kititem[0].subnote->setVelocity(vel);
+                if(kit[0].Ppadenabled)
+                    partnote[i].kititem[0].padnote->setVelocity(vel);
+            }
+            else     // "kit mode"
+                for(int item = 0; item < NUM_KIT_ITEMS; ++item) {
+                    if(kit[item].Pmuted)
+                        continue;
+                    if((note < kit[item].Pminkey)
+                       || (note > kit[item].Pmaxkey))
+                        continue;
+
+                    int ci = partnote[i].itemsplaying; // ci=current item
+                    if(kit[item].Padenabled)
+                        partnote[i].kititem[item].adnote->setVelocity(vel);
+                    if(kit[item].Psubenabled)
+                        partnote[i].kititem[item].subnote->setVelocity(vel);
+                    if(kit[item].Ppadenabled)
+                        partnote[i].kititem[item].padnote->setVelocity(vel);
+                }
+        }
+
+}
+
 /*
  * Controllers
  */
diff --git a/src/Misc/Part.h b/src/Misc/Part.h
index ef523b69..c1544820 100644
--- a/src/Misc/Part.h
+++ b/src/Misc/Part.h
@@ -56,6 +56,9 @@ class Part
                     unsigned char velocity,
                     int masterkeyshift);
         void NoteOff(unsigned char note);
+        void PolyphonicAftertouch(unsigned char note,
+                                  unsigned char velocity,
+                                  int masterkeyshift);
         void AllNotesOff(); //panic
         void SetController(unsigned int type, int par);
         void RelaseSustainedKeys(); //this is called when the sustain pedal is relased
diff --git a/src/Nio/AlsaEngine.cpp b/src/Nio/AlsaEngine.cpp
index 4ae452f5..434e2fbd 100644
--- a/src/Nio/AlsaEngine.cpp
+++ b/src/Nio/AlsaEngine.cpp
@@ -136,6 +136,14 @@ void *AlsaEngine::MidiThread(void)
                 InMgr::getInstance().putEvent(ev);
                 break;
 
+            case SND_SEQ_EVENT_KEYPRESS:
+                ev.type    = M_PRESSURE;
+                ev.channel = event->data.note.channel;
+                ev.num     = event->data.note.note;
+                ev.value   = event->data.note.velocity;
+                InMgr::getInstance().putEvent(ev);
+                break;
+
             case SND_SEQ_EVENT_PITCHBEND:
                 ev.type    = M_CONTROLLER;
                 ev.channel = event->data.control.channel;
diff --git a/src/Nio/InMgr.cpp b/src/Nio/InMgr.cpp
index 04846fda..af8d63c8 100644
--- a/src/Nio/InMgr.cpp
+++ b/src/Nio/InMgr.cpp
@@ -86,6 +86,9 @@ void InMgr::flush()
             case M_PGMCHANGE:
                 master.setProgram(ev.channel, ev.num);
                 break;
+            case M_PRESSURE:
+                master.polyphonicAftertouch(ev.channel, ev.num, ev.value);
+                break;
         }
     }
 }
diff --git a/src/Nio/InMgr.h b/src/Nio/InMgr.h
index 86d09fad..03dcad07 100644
--- a/src/Nio/InMgr.h
+++ b/src/Nio/InMgr.h
@@ -8,8 +8,10 @@
 enum midi_type {
     M_NOTE = 1,
     M_CONTROLLER = 2,
-    M_PGMCHANGE  = 3
+    M_PGMCHANGE  = 3,
+    M_PRESSURE   = 4
 };    //type=1 for note, type=2 for controller, type=3 for program change
+//type=4 for polyphonic aftertouch
 
 struct MidiEvent {
     MidiEvent();
diff --git a/src/Nio/JackEngine.cpp b/src/Nio/JackEngine.cpp
index 0ff198ad..8af0c387 100644
--- a/src/Nio/JackEngine.cpp
+++ b/src/Nio/JackEngine.cpp
@@ -368,6 +368,13 @@ void JackEngine::handleMidi(unsigned long frames)
                 InMgr::getInstance().putEvent(ev);
                 break;
 
+            case 0xA0: /* pressure, aftertouch */
+                ev.type  = M_PRESSURE;
+                ev.num   = midi_data[1];
+                ev.value = midi_data[2];
+                InMgr::getInstance().putEvent(ev);
+                break;
+
             case 0xB0: /* controller */
                 ev.type  = M_CONTROLLER;
                 ev.num   = midi_data[1];
diff --git a/src/Nio/MidiIn.cpp b/src/Nio/MidiIn.cpp
index 4bf22d9b..3635bde2 100644
--- a/src/Nio/MidiIn.cpp
+++ b/src/Nio/MidiIn.cpp
@@ -45,6 +45,13 @@ void MidiIn::midiProcess(unsigned char head,
             ev.value   = value;
             InMgr::getInstance().putEvent(ev);
             break;
+        case 0xA0: /* pressure, aftertouch */
+            ev.type    = M_PRESSURE;
+            ev.channel = chan;
+            ev.num     = num;
+            ev.value   = value;
+            InMgr::getInstance().putEvent(ev);
+            break;
         case 0xb0: //Controller
             ev.type    = M_CONTROLLER;
             ev.channel = chan;
diff --git a/src/Synth/SynthNote.cpp b/src/Synth/SynthNote.cpp
index f501f3f5..578a1173 100644
--- a/src/Synth/SynthNote.cpp
+++ b/src/Synth/SynthNote.cpp
@@ -125,3 +125,10 @@ void SynthNote::Legato::apply(SynthNote &note, float *outl, float *outr)
             break;
     }
 }
+
+void SynthNote::setVelocity(float velocity_) {
+    legato.setSilent(true); //Let legato.update(...) returns 0.
+    legatonote(legato.getFreq(), velocity_,
+               legato.getPortamento(), legato.getMidinote(), true);
+    legato.setDecounter(0); //avoid chopping sound due fade-in
+}
diff --git a/src/Synth/SynthNote.h b/src/Synth/SynthNote.h
index bc5ba2ec..3058e5d3 100644
--- a/src/Synth/SynthNote.h
+++ b/src/Synth/SynthNote.h
@@ -45,6 +45,8 @@ class SynthNote
         virtual void legatonote(float freq, float velocity,
                                 int portamento_, int midinote_,
                                 bool externcall) = 0;
+        /* For polyphonic aftertouch needed */
+        void setVelocity(float velocity_);
     protected:
         // Legato transitions
         class Legato
@@ -70,6 +72,14 @@ class SynthNote
                     float freq, vel;
                     int   portamento, midinote;
                 } param;
+
+            public: /* Some get routines for legatonote calls (aftertouch feature)*/
+                float getFreq() {return param.freq; }
+                float getVelocity() {return param.vel; }
+                int getPortamento() {return param.portamento; }
+                int getMidinote() {return param.midinote; }
+                void setSilent(bool silent_) {silent = silent_; }
+                void setDecounter(int decounter_) {decounter = decounter_; }
         } legato;
 };
 
-- 
2.47.0

