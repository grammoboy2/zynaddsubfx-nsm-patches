From 186580a4ed07eed509f13d1996a16450c4fb0247 Mon Sep 17 00:00:00 2001
From: fundamental <mark.d.mccurry@gmail.com>
Date: Thu, 13 Nov 2014 15:19:51 -0500
Subject: [PATCH 0287/1936] Minor Touchups To Allocator

---
 src/Misc/Allocator.cpp | 25 +++++++++++++++----------
 src/Misc/Allocator.h   | 26 ++++----------------------
 2 files changed, 19 insertions(+), 32 deletions(-)

diff --git a/src/Misc/Allocator.cpp b/src/Misc/Allocator.cpp
index 5a9ed6ee..38031721 100644
--- a/src/Misc/Allocator.cpp
+++ b/src/Misc/Allocator.cpp
@@ -1,5 +1,6 @@
 #include <cstddef>
 #include <cstdlib>
+#include <cassert>
 #include <utility>
 #include <cstdio>
 #include "../../tlsf/tlsf.h"
@@ -20,12 +21,13 @@ void *data(next_t *n)
 
 struct AllocatorImpl
 {
-    void *tlsf = 0;;
+    void *tlsf = 0;
 
     //singly linked list of memory pools
     //XXX this may violate alignment on some platforms if malloc doesn't return
     //nice values
     next_t *pools = 0;
+    unsigned long long totalAlloced = 0;
 };
 
 Allocator::Allocator(void)
@@ -54,6 +56,7 @@ Allocator::~Allocator(void)
 
 void *Allocator::alloc_mem(size_t mem_size)
 {
+    impl->totalAlloced += mem_size;
     void *mem = tlsf_malloc(impl->tlsf, mem_size);
     //printf("Allocator.malloc(%p, %d) = %p\n", impl, mem_size, mem);
     //void *mem = malloc(mem_size);
@@ -62,7 +65,7 @@ void *Allocator::alloc_mem(size_t mem_size)
 }
 void Allocator::dealloc_mem(void *memory)
 {
-    //fprintf(stderr, "Freeing memory (%p)\n", memory);
+    //printf("dealloc_mem(%d)\n", tlsf_block_size(memory));
     tlsf_free(impl->tlsf, memory);
     //free(memory);
 }
@@ -119,24 +122,20 @@ static const size_t block_header_free_bit = 1 << 0;
 bool Allocator::memFree(void *pool)
 {
     size_t bh_shift = sizeof(next_t)+sizeof(size_t);
-    //printf("memFree(%p)\n", pool);
+    //Assume that memory is free to start with
     bool isFree = true;
+    //Get the block header from the pool
     block_header_t &bh  = *(block_header_t*)((char*)pool+bh_shift);
-    //printf("size_test = %x\n", 50*1024*1024);
-    //printf("size1     = %x\n", bh.size);
+    //The first block must be free
     if((bh.size&block_header_free_bit) == 0)
         isFree = false;
-    //printf("Step 1 = %d\n", isFree);
     block_header_t &bhn = *(block_header_t*)
         (((char*)&bh)+((bh.size&~0x3)+bh_shift-2*sizeof(size_t)));
-    //printf("size2     = %x\n", bhn.size);
+    //The next block must be 'non-free' and zero length
     if((bhn.size&block_header_free_bit) != 0)
         isFree = false;
-    //printf("Step 2 = %d\n", isFree);
     if((bhn.size&~0x3) != 0)
         isFree = false;
-    //printf("Step 3 = %d\n", isFree);
-    //printf("Result = %d\n\n", isFree);
 
     return isFree;
 }
@@ -164,6 +163,12 @@ int Allocator::freePools()
     return i;
 }
 
+
+unsigned long long Allocator::totalAlloced()
+{
+    return impl->totalAlloced;
+}
+
 /*
  * Notes on tlsf internals
  * - TLSF consists of blocks linked by block headers and these form a doubly
diff --git a/src/Misc/Allocator.h b/src/Misc/Allocator.h
index e9caf9e0..1e6794b2 100644
--- a/src/Misc/Allocator.h
+++ b/src/Misc/Allocator.h
@@ -62,10 +62,10 @@ class Allocator
             }
         }
 
-    void addMemory(void *, size_t mem_size);//{(void)mem_size;};
+    void addMemory(void *, size_t mem_size);
 
     //Return true if the current pool cannot allocate n chunks of chunk_size
-    bool lowMemory(unsigned n, size_t chunk_size);//{(void)n;(void)chunk_size; return false;};
+    bool lowMemory(unsigned n, size_t chunk_size);
     bool memFree(void *pool);
 
     //returns number of pools
@@ -73,29 +73,11 @@ class Allocator
 
     int freePools();
 
+    unsigned long long totalAlloced();
+
     struct AllocatorImpl *impl;
 };
 
-//Memory that could either be from the heap or from the realtime allocator
-//This should be avoided when possible, but it's not clear if it can be avoided
-//in all cases
-//template<class T>
-//class HeapRtMem
-//{
-//};
-
-
-//A helper class used to perform a series of allocations speculatively to verify
-//that there is enough memory for a set transation to occur.
-//Stuff will get weird if this ends up failing, but it will be able to at least
-//detect where there is an issue
-//class StaticAllocFreeVerifyier
-//{
-//    void *scratch_buf[4096];
-//    unsigned alloc_count;
-//};
-
-
 /**
  * General notes on Memory Allocation Within ZynAddSubFX
  * -----------------------------------------------------
-- 
2.47.0

