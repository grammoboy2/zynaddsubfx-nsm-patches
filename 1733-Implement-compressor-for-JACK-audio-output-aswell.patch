From b6e650a4e7915439ed643b1f9c2105676dd6e79d Mon Sep 17 00:00:00 2001
From: Hans Petter Selasky <hps@selasky.org>
Date: Sun, 30 May 2021 18:34:26 +0200
Subject: [PATCH 1733/1936] Implement compressor for JACK audio output aswell.

Signed-off-by: Hans Petter Selasky <hps@selasky.org>
---
 src/Nio/JackEngine.cpp      |  9 +++++++++
 src/Nio/JackEngine.h        |  1 +
 src/Nio/JackMultiEngine.cpp | 22 ++++++++++++++++++++++
 3 files changed, 32 insertions(+)

diff --git a/src/Nio/JackEngine.cpp b/src/Nio/JackEngine.cpp
index 634eea2b..be2c2ea6 100644
--- a/src/Nio/JackEngine.cpp
+++ b/src/Nio/JackEngine.cpp
@@ -26,6 +26,7 @@
 #include <fstream> // std::istream
 
 #include "Nio.h"
+#include "Compressor.h"
 #include "OutMgr.h"
 #include "InMgr.h"
 #include "Misc/Util.h"
@@ -44,6 +45,7 @@ JackEngine::JackEngine(const SYNTH_T &synth)
     name = "JACK";
     audio.jackSamplerate = 0;
     audio.jackNframes    = 0;
+    audio.peaks[0] = 0;
     for(int i = 0; i < 2; ++i) {
         audio.ports[i]     = NULL;
         audio.portBuffs[i] = NULL;
@@ -344,6 +346,13 @@ bool JackEngine::processAudio(jack_nframes_t nframes)
     //Assumes size of smp.l == nframes
     memcpy(audio.portBuffs[0], smp.l, bufferSize * sizeof(float));
     memcpy(audio.portBuffs[1], smp.r, bufferSize * sizeof(float));
+
+    //Make sure the audio output doesn't overflow
+    for(int frame = 0; frame != bufferSize; ++frame) {
+        float &l = audio.portBuffs[0][frame];
+        float &r = audio.portBuffs[1][frame];
+        stereoCompressor(synth.samplerate, audio.peaks[0], l, r);
+    }
     return true;
 }
 
diff --git a/src/Nio/JackEngine.h b/src/Nio/JackEngine.h
index 157de80c..0d45505b 100644
--- a/src/Nio/JackEngine.h
+++ b/src/Nio/JackEngine.h
@@ -73,6 +73,7 @@ class JackEngine:public AudioOut, MidiIn
             unsigned int jackNframes;
             jack_port_t *ports[2];
             jsample_t   *portBuffs[2];
+            float peaks[1];
         } audio;
         struct osc {
             jack_port_t *oscport;
diff --git a/src/Nio/JackMultiEngine.cpp b/src/Nio/JackMultiEngine.cpp
index 982df973..41b1e62f 100644
--- a/src/Nio/JackMultiEngine.cpp
+++ b/src/Nio/JackMultiEngine.cpp
@@ -19,6 +19,7 @@
 #include <cassert>
 
 #include "Nio.h"
+#include "Compressor.h"
 #include "../Misc/Util.h"
 #include "../Misc/Master.h"
 #include "../Misc/Part.h"
@@ -35,6 +36,7 @@ using std::string;
 struct jack_multi
 {
     jack_port_t *ports[NUM_MIDI_PARTS * 2 + 2];
+    float peaks[NUM_MIDI_PARTS + 1];
     jack_client_t *client;
     bool running;
 };
@@ -44,6 +46,7 @@ JackMultiEngine::JackMultiEngine(const SYNTH_T &synth)
 {
     impl->running = false;
     impl->client  = NULL;
+    memset(impl->peaks, 0, sizeof(impl->peaks));
 
     name = "JACK-MULTI";
 }
@@ -148,11 +151,30 @@ int JackMultiEngine::processAudio(jack_nframes_t nframes)
     memcpy(buffers[0], smp.l, synth.bufferbytes);
     memcpy(buffers[1], smp.r, synth.bufferbytes);
 
+    const int maxFrames = (synth.bufferbytes / sizeof(float));
+
+    //Make sure the audio output doesn't overflow
+    for(int frame = 0; frame != maxFrames; ++frame) {
+	float &p = impl->peaks[0];
+	float &l = buffers[0][frame];
+	float &r = buffers[1][frame];
+	stereoCompressor(synth.samplerate, p, l, r);
+    }
+
     //Gather other samples from individual parts
     Master &master = *middleware->spawnMaster();
     for(int i = 0; i < NUM_MIDI_PARTS; ++i) {
+        float &p = impl->peaks[i + 1];
+
         memcpy(buffers[2*i + 2], master.part[i]->partoutl, synth.bufferbytes);
         memcpy(buffers[2*i + 3], master.part[i]->partoutr, synth.bufferbytes);
+
+        //Make sure the audio output doesn't overflow
+        for(int frame = 0; frame != maxFrames; ++frame) {
+            float &l = buffers[2*i + 2][frame];
+            float &r = buffers[2*i + 3][frame];
+            stereoCompressor(synth.samplerate, p, l, r);
+        }
     }
 
     return false;
-- 
2.47.0

