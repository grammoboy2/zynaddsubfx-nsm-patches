From c05bff25f45f11e410662113a5ae17739ee72945 Mon Sep 17 00:00:00 2001
From: fundamental <mark.d.mccurry@gmail.com>
Date: Sun, 11 Mar 2012 22:26:53 -0400
Subject: [PATCH 0001/1936] JackMultiEngine: Created engine

- JackMultiEngine is an experimental engine for allowing jack to produce outputs
  for each instrument's part
- Currently this module is restricted to only outputting when jack and zyn's
  buffer size/sample rates are identical
---
 src/Nio/CMakeLists.txt      |   2 +-
 src/Nio/EngineMgr.cpp       |   2 +
 src/Nio/JackMultiEngine.cpp | 171 ++++++++++++++++++++++++++++++++++++
 src/Nio/JackMultiEngine.h   |  46 ++++++++++
 4 files changed, 220 insertions(+), 1 deletion(-)
 create mode 100644 src/Nio/JackMultiEngine.cpp
 create mode 100644 src/Nio/JackMultiEngine.h

diff --git a/src/Nio/CMakeLists.txt b/src/Nio/CMakeLists.txt
index 6fb718b0..fec010dc 100644
--- a/src/Nio/CMakeLists.txt
+++ b/src/Nio/CMakeLists.txt
@@ -29,7 +29,7 @@ endif()
 
 if(JackEnable)
     include_directories(${JACK_INCLUDE_DIR})
-    list(APPEND zynaddsubfx_nio_SRCS JackEngine.cpp)
+    list(APPEND zynaddsubfx_nio_SRCS JackEngine.cpp JackMultiEngine.cpp)
     list(APPEND zynaddsubfx_nio_lib ${JACK_LIBRARIES})
 endif(JackEnable)
 
diff --git a/src/Nio/EngineMgr.cpp b/src/Nio/EngineMgr.cpp
index 3dfb6351..4065f3ff 100644
--- a/src/Nio/EngineMgr.cpp
+++ b/src/Nio/EngineMgr.cpp
@@ -15,6 +15,7 @@
 #endif
 #if JACK
 #include "JackEngine.h"
+#include "JackMultiEngine.h"
 #endif
 #if PORTAUDIO
 #include "PaEngine.h"
@@ -54,6 +55,7 @@ EngineMgr::EngineMgr()
 #else
     engines.push_back(new JackEngine());
 #endif
+    engines.push_back(new JackMultiEngine());
 #endif
 #if PORTAUDIO
 #if PORTAUDIO_DEFAULT
diff --git a/src/Nio/JackMultiEngine.cpp b/src/Nio/JackMultiEngine.cpp
new file mode 100644
index 00000000..04eeea80
--- /dev/null
+++ b/src/Nio/JackMultiEngine.cpp
@@ -0,0 +1,171 @@
+/*
+  ZynAddSubFX - a software synthesizer
+
+  JackMultiEngine.cpp - Channeled Audio output JACK
+  Copyright (C) 2012-2012 Mark McCurry
+  Author: Mark McCurry
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of version 2 of the GNU General Public License
+  as published by the Free Software Foundation.
+
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License (version 2 or later) for more details.
+
+  You should have received a copy of the GNU General Public License (version 2)
+  along with this program; if not, write to the Free Software Foundation,
+  Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+
+*/
+
+#include <jack/jack.h>
+#include <string>
+#include <cstring>
+#include <err.h>
+#include <cstdio>
+#include <cassert>
+
+#include "Nio.h"
+#include "../Misc/Master.h"
+#include "../Misc/Part.h"
+
+#include "JackMultiEngine.h"
+
+using std::string;
+
+struct jack_multi
+{
+    jack_port_t *ports[NUM_MIDI_PARTS * 2 + 2];
+    jack_client_t *client;
+    bool running;
+};
+
+JackMultiEngine::JackMultiEngine(void)
+    :impl(new jack_multi())
+{
+    impl->running = false;
+    impl->client  = NULL;
+
+    name = "JACK-MULTI";
+}
+
+JackMultiEngine::~JackMultiEngine(void)
+{
+    delete impl;
+}
+
+void JackMultiEngine::setAudioEn(bool nval)
+{
+    if(nval)
+        Start();
+    else
+        Stop();
+}
+
+bool JackMultiEngine::getAudioEn() const
+{
+    return impl->running;
+}
+
+
+
+bool JackMultiEngine::Start(void)
+{
+    if(impl->client)
+        return true;
+
+    string clientname = "zynaddsubfx";
+    string postfix    = Nio::getPostfix();
+    if(!postfix.empty())
+        clientname += "_" + postfix;
+    jack_status_t jackstatus;
+
+    impl->client = jack_client_open(clientname.c_str(), JackNullOption, &jackstatus);
+
+    if(!impl->client)
+        errx(1, "failed to connect to jack...");
+    
+    
+    //Create the set of jack ports
+    char portName[20];
+    memset(portName,0,sizeof(portName));
+
+#define JACK_REGISTER(x) jack_port_register(impl->client, x, \
+        JACK_DEFAULT_AUDIO_TYPE, JackPortIsOutput | JackPortIsTerminal, 0)
+    //Create the master wet port
+
+    impl->ports[0] = JACK_REGISTER("wet_l");
+    impl->ports[1] = JACK_REGISTER("wet_r");
+
+    //Create all part's outputs
+    for(int i = 0; i < NUM_MIDI_PARTS * 2; i += 2) {
+        snprintf(portName, 19, "part_%dl", i / 2);
+        impl->ports[2 + i] = JACK_REGISTER(portName);
+        snprintf(portName, 19, "part_%dr", i / 2);
+        impl->ports[3 + i] = JACK_REGISTER(portName);
+    }
+
+    //verify that all sample rate and buffer_size are the same in jack.
+    //This insures that the connection can be made with no resampling or
+    //buffering
+    if(synth->samplerate != jack_get_sample_rate(impl->client))
+        errx(1, "jack must have the same sample rate!");
+    if(synth->buffersize != (int) jack_get_buffer_size(impl->client))
+        errx(1, "jack must have the same buffer size");
+
+    jack_set_process_callback(impl->client, _processCallback, this);
+
+    //run
+    if(jack_activate(impl->client)) 
+        errx(1, "failed at starting the jack client");
+    impl->running = true;
+    return true;
+}
+
+int JackMultiEngine::_processCallback(jack_nframes_t nframes, void *arg)
+{
+    return static_cast<JackMultiEngine *>(arg)->processAudio(nframes);
+}
+
+int JackMultiEngine::processAudio(jack_nframes_t nframes)
+{
+    //Gather all buffers
+    float *buffers[NUM_MIDI_PARTS * 2 + 2];
+
+    for(int i = 0; i < NUM_MIDI_PARTS * 2 + 2; ++i) {
+        buffers[i] =
+            (float *)jack_port_get_buffer(impl->ports[i], nframes);
+        assert(buffers[i]);
+    }
+
+    //Get the wet samples from OutMgr
+    Stereo<float *> smp = getNext();
+    memcpy(buffers[0], smp.l, synth->bufferbytes);
+    memcpy(buffers[1], smp.r, synth->bufferbytes);
+
+    //Gather other samples from individual parts
+    Master &master = Master::getInstance();
+    for(int i = 0; i < NUM_MIDI_PARTS; ++i) {
+        memcpy(buffers[2*i + 2], master.part[i]->partoutl, synth->bufferbytes);
+        memcpy(buffers[2*i + 3], master.part[i]->partoutr, synth->bufferbytes);
+    }
+
+    return true;
+}
+
+void JackMultiEngine::Stop()
+{
+    for(int i = 0; i < NUM_MIDI_PARTS * 2 + 2; ++i) {
+        jack_port_t *port = impl->ports[i];
+        impl->ports[i] = NULL;
+        if(port)
+            jack_port_unregister(impl->client, port);
+    }
+
+    jack_client_close(impl->client);
+    impl->client = NULL;
+
+    impl->running = false;
+}
diff --git a/src/Nio/JackMultiEngine.h b/src/Nio/JackMultiEngine.h
new file mode 100644
index 00000000..6ccd0a69
--- /dev/null
+++ b/src/Nio/JackMultiEngine.h
@@ -0,0 +1,46 @@
+/*
+  ZynAddSubFX - a software synthesizer
+
+  JackMultiEngine.h - Channeled Audio output JACK
+  Copyright (C) 2012-2012 Mark McCurry
+  Author: Mark McCurry
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of version 2 of the GNU General Public License
+  as published by the Free Software Foundation.
+
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License (version 2 or later) for more details.
+
+  You should have received a copy of the GNU General Public License (version 2)
+  along with this program; if not, write to the Free Software Foundation,
+  Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+
+*/
+#ifndef JACK_MULTI_ENGINE
+#define JACK_MULTI_ENGINE
+
+#include "AudioOut.h"
+
+class JackMultiEngine:public AudioOut
+{
+    public:
+        JackMultiEngine(void);
+        ~JackMultiEngine(void);
+
+        void setAudioEn(bool nval);
+        bool getAudioEn() const;
+
+        bool Start(void);
+        void Stop(void);
+
+    private:
+        static int _processCallback(unsigned nframes, void *arg);
+        int processAudio(unsigned nframes);
+
+        struct jack_multi *impl;
+};
+
+#endif
-- 
2.47.0

