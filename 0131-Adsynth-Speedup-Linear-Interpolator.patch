From 8918867e6e15afa19cf5ac62399b3d3579c165d8 Mon Sep 17 00:00:00 2001
From: fundamental <mark.d.mccurry@gmail.com>
Date: Mon, 19 Aug 2013 00:03:52 -0400
Subject: [PATCH 0131/1936] Adsynth: Speedup Linear Interpolator

Replace unneeded floating point ops with fixed point ones
resulting in a ~15% speedup observed in ADnoteTest
---
 src/Synth/ADnote.cpp | 39 +++++++++++++++++++++++++--------------
 1 file changed, 25 insertions(+), 14 deletions(-)

diff --git a/src/Synth/ADnote.cpp b/src/Synth/ADnote.cpp
index cd376f6c..2d76cea0 100644
--- a/src/Synth/ADnote.cpp
+++ b/src/Synth/ADnote.cpp
@@ -23,6 +23,8 @@
 #include <cstdlib>
 #include <cstdio>
 #include <cstring>
+#include <cassert>
+#include <stdint.h>
 
 #include "../globals.h"
 #include "../Misc/Util.h"
@@ -1102,30 +1104,39 @@ inline void ADnote::fadein(float *smps) const
 /*
  * Computes the Oscillator (Without Modulation) - LinearInterpolation
  */
+
+/* As the code here is a bit odd due to optimization, here is what happens
+ * First the current possition and frequency are retrieved from the running
+ * state. These are broken up into high and low portions to indicate how many
+ * samples are skipped in one step and how many fractional samples are skipped.
+ * Outside of this method the fractional samples are just handled with floating
+ * point code, but that's a bit slower than it needs to be. In this code the low
+ * portions are known to exist between 0.0 and 1.0 and it is known that they are
+ * stored in single precision floating point IEEE numbers. This implies that
+ * a maximum of 24 bits are significant. The below code does your standard
+ * linear interpolation that you'll see throughout this codebase, but by
+ * sticking to integers for tracking the overflow of the low portion, around 15%
+ * of the execution time was shaved off in the ADnote test.
+ */
 inline void ADnote::ComputeVoiceOscillator_LinearInterpolation(int nvoice)
 {
-    int   i, poshi;
-    float poslo;
-
     for(int k = 0; k < unison_size[nvoice]; ++k) {
-        poshi = oscposhi[nvoice][k];
-        poslo = oscposlo[nvoice][k];
+        int    poshi  = oscposhi[nvoice][k];
+        int    poslo  = oscposlo[nvoice][k] * (1<<24);
         int    freqhi = oscfreqhi[nvoice][k];
-        float  freqlo = oscfreqlo[nvoice][k];
+        int    freqlo = oscfreqlo[nvoice][k] * (1<<24);
         float *smps   = NoteVoicePar[nvoice].OscilSmp;
         float *tw     = tmpwave_unison[k];
-        for(i = 0; i < synth->buffersize; ++i) {
-            tw[i]  = smps[poshi] * (1.0f - poslo) + smps[poshi + 1] * poslo;
+        assert(oscfreqlo[nvoice][k] < 1.0f);
+        for(int i = 0; i < synth->buffersize; ++i) {
+            tw[i]  = (smps[poshi] * ((1<<24) - poslo) + smps[poshi + 1] * poslo)/(1.0f*(1<<24));
             poslo += freqlo;
-            if(poslo >= 1.0f) {
-                poslo -= 1.0f;
-                poshi++;
-            }
-            poshi += freqhi;
+            poshi += freqhi + (poslo>>24);
+            poslo &= 0xffffff;
             poshi &= synth->oscilsize - 1;
         }
         oscposhi[nvoice][k] = poshi;
-        oscposlo[nvoice][k] = poslo;
+        oscposlo[nvoice][k] = poslo/(1.0f*(1<<24));
     }
 }
 
-- 
2.47.0

