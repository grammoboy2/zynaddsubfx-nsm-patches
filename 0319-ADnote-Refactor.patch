From ce7a8a9ea54470e81ec801debaf2ea6965d5bdfc Mon Sep 17 00:00:00 2001
From: fundamental <mark.d.mccurry@gmail.com>
Date: Sat, 14 Feb 2015 15:21:33 -0500
Subject: [PATCH 0319/1936] ADnote: Refactor

---
 src/Params/ADnoteParameters.cpp |   8 +-
 src/Params/ADnoteParameters.h   |   6 +-
 src/Synth/ADnote.cpp            | 367 ++++++++++++++++----------------
 src/Synth/ADnote.h              |   3 +-
 4 files changed, 187 insertions(+), 197 deletions(-)

diff --git a/src/Params/ADnoteParameters.cpp b/src/Params/ADnoteParameters.cpp
index ad977c97..3c5d2f4c 100644
--- a/src/Params/ADnoteParameters.cpp
+++ b/src/Params/ADnoteParameters.cpp
@@ -455,7 +455,7 @@ void ADnoteVoiceParam::enable(FFTwrapper *fft, Resonance *Reson)
 /*
  * Get the Multiplier of the fine detunes of the voices
  */
-float ADnoteParameters::getBandwidthDetuneMultiplier()
+float ADnoteParameters::getBandwidthDetuneMultiplier() const
 {
     float bw = (GlobalPar.PBandwidth - 64.0f) / 64.0f;
     bw = powf(2.0f, bw * powf(fabs(bw), 0.2f) * 5.0f);
@@ -467,7 +467,8 @@ float ADnoteParameters::getBandwidthDetuneMultiplier()
  * Get the unison spread in cents for a voice
  */
 
-float ADnoteParameters::getUnisonFrequencySpreadCents(int nvoice) {
+float ADnoteParameters::getUnisonFrequencySpreadCents(int nvoice) const
+{
     return VoicePar[nvoice].getUnisonFrequencySpreadCents();
 }
 
@@ -521,7 +522,8 @@ ADnoteParameters::~ADnoteParameters()
         KillVoice(nvoice);
 }
 
-int ADnoteParameters::get_unison_size_index(int nvoice) {
+int ADnoteParameters::get_unison_size_index(int nvoice) const
+{
     int index = 0;
     if(nvoice >= NUM_VOICES)
         return 0;
diff --git a/src/Params/ADnoteParameters.h b/src/Params/ADnoteParameters.h
index 5ccdedd8..119a932b 100644
--- a/src/Params/ADnoteParameters.h
+++ b/src/Params/ADnoteParameters.h
@@ -297,9 +297,9 @@ class ADnoteParameters:public PresetsArray
         void add2XML(XMLwrapper *xml);
         void getfromXML(XMLwrapper *xml);
 
-        float getBandwidthDetuneMultiplier();
-        float getUnisonFrequencySpreadCents(int nvoice);
-        int get_unison_size_index(int nvoice);
+        float getBandwidthDetuneMultiplier() const;
+        float getUnisonFrequencySpreadCents(int nvoice) const;
+        int get_unison_size_index(int nvoice) const;
         void set_unison_size_index(int nvoice, int index);
         static rtosc::Ports &ports;
     private:
diff --git a/src/Synth/ADnote.cpp b/src/Synth/ADnote.cpp
index 5223ad68..092de251 100644
--- a/src/Synth/ADnote.cpp
+++ b/src/Synth/ADnote.cpp
@@ -36,60 +36,59 @@
 #include "ADnote.h"
 
 
-ADnote::ADnote(ADnoteParameters *pars, SynthParams &spars)
-    :SynthNote(spars)
+ADnote::ADnote(ADnoteParameters *pars_, SynthParams &spars)
+    :SynthNote(spars), pars(*pars_)
 {
     tmpwavel = memory.valloc<float>(synth->buffersize);
     tmpwaver = memory.valloc<float>(synth->buffersize);
     bypassl  = memory.valloc<float>(synth->buffersize);
     bypassr  = memory.valloc<float>(synth->buffersize);
 
-    partparams = pars;
-    ctl = &spars.ctl;
+    ADnoteParameters &pars = *pars_;
     portamento  = spars.portamento;
     midinote    = spars.note;
     NoteEnabled = ON;
     basefreq    = spars.frequency;
     velocity    = spars.velocity;
     time   = 0.0f;
-    stereo = pars->GlobalPar.PStereo;
+    stereo = pars.GlobalPar.PStereo;
 
-    NoteGlobalPar.Detune = getdetune(pars->GlobalPar.PDetuneType,
-                                     pars->GlobalPar.PCoarseDetune,
-                                     pars->GlobalPar.PDetune);
-    bandwidthDetuneMultiplier = pars->getBandwidthDetuneMultiplier();
+    NoteGlobalPar.Detune = getdetune(pars.GlobalPar.PDetuneType,
+                                     pars.GlobalPar.PCoarseDetune,
+                                     pars.GlobalPar.PDetune);
+    bandwidthDetuneMultiplier = pars.getBandwidthDetuneMultiplier();
 
-    if(pars->GlobalPar.PPanning == 0)
+    if(pars.GlobalPar.PPanning == 0)
         NoteGlobalPar.Panning = RND;
     else
-        NoteGlobalPar.Panning = pars->GlobalPar.PPanning / 128.0f;
+        NoteGlobalPar.Panning = pars.GlobalPar.PPanning / 128.0f;
 
 
-    NoteGlobalPar.FilterCenterPitch = pars->GlobalPar.GlobalFilter->getfreq() //center freq
-                                      + pars->GlobalPar.PFilterVelocityScale
-                                      / 127.0f * 6.0f                                  //velocity sensing
+    NoteGlobalPar.FilterCenterPitch = pars.GlobalPar.GlobalFilter->getfreq() //center freq
+                                      + pars.GlobalPar.PFilterVelocityScale
+                                      / 127.0f * 6.0f       //velocity sensing
                                       * (VelF(velocity,
-                                              pars->GlobalPar.
+                                              pars.GlobalPar.
                                               PFilterVelocityScaleFunction) - 1);
 
-    if(pars->GlobalPar.PPunchStrength != 0) {
+    if(pars.GlobalPar.PPunchStrength != 0) {
         NoteGlobalPar.Punch.Enabled = 1;
         NoteGlobalPar.Punch.t = 1.0f; //start from 1.0f and to 0.0f
         NoteGlobalPar.Punch.initialvalue =
-            ((powf(10, 1.5f * pars->GlobalPar.PPunchStrength / 127.0f) - 1.0f)
+            ((powf(10, 1.5f * pars.GlobalPar.PPunchStrength / 127.0f) - 1.0f)
              * VelF(velocity,
-                    pars->GlobalPar.PPunchVelocitySensing));
+                    pars.GlobalPar.PPunchVelocitySensing));
         float time =
-            powf(10, 3.0f * pars->GlobalPar.PPunchTime / 127.0f) / 10000.0f;   //0.1f .. 100 ms
+            powf(10, 3.0f * pars.GlobalPar.PPunchTime / 127.0f) / 10000.0f;   //0.1f .. 100 ms
         float stretch = powf(440.0f / spars.frequency,
-                             pars->GlobalPar.PPunchStretch / 64.0f);
+                             pars.GlobalPar.PPunchStretch / 64.0f);
         NoteGlobalPar.Punch.dt = 1.0f / (time * synth->samplerate_f * stretch);
     }
     else
         NoteGlobalPar.Punch.Enabled = 0;
 
     for(int nvoice = 0; nvoice < NUM_VOICES; ++nvoice) {
-        pars->VoicePar[nvoice].OscilSmp->newrandseed(prng());
+        pars.VoicePar[nvoice].OscilSmp->newrandseed(prng());
         NoteVoicePar[nvoice].OscilSmp = NULL;
         NoteVoicePar[nvoice].FMSmp    = NULL;
         NoteVoicePar[nvoice].VoiceOut = NULL;
@@ -97,14 +96,14 @@ ADnote::ADnote(ADnoteParameters *pars, SynthParams &spars)
         NoteVoicePar[nvoice].FMVoice = -1;
         unison_size[nvoice] = 1;
 
-        if(pars->VoicePar[nvoice].Enabled == 0) {
+        if(!pars.VoicePar[nvoice].Enabled) {
             NoteVoicePar[nvoice].Enabled = OFF;
             continue; //the voice is disabled
         }
 
         unison_stereo_spread[nvoice] =
-            pars->VoicePar[nvoice].Unison_stereo_spread / 127.0f;
-        int unison = pars->VoicePar[nvoice].Unison_size;
+            pars.VoicePar[nvoice].Unison_stereo_spread / 127.0f;
+        int unison = pars.VoicePar[nvoice].Unison_size;
         if(unison < 1)
             unison = 1;
 
@@ -114,11 +113,11 @@ ADnote::ADnote(ADnoteParameters *pars, SynthParams &spars)
         unison_base_freq_rap[nvoice] = memory.valloc<float>(unison);
         unison_freq_rap[nvoice]      = memory.valloc<float>(unison);
         unison_invert_phase[nvoice]  = memory.valloc<bool>(unison);
-        float unison_spread = pars->getUnisonFrequencySpreadCents(
-            nvoice);
+        float unison_spread =
+            pars.getUnisonFrequencySpreadCents(nvoice);
         float unison_real_spread = powf(2.0f, (unison_spread * 0.5f) / 1200.0f);
-        float unison_vibratto_a  = pars->VoicePar[nvoice].Unison_vibratto
-                                   / 127.0f;                                     //0.0f .. 1.0f
+        float unison_vibratto_a  =
+            pars.VoicePar[nvoice].Unison_vibratto / 127.0f; //0.0f .. 1.0f
 
 
         switch(unison) {
@@ -167,13 +166,8 @@ ADnote::ADnote(ADnoteParameters *pars, SynthParams &spars)
             (unison_real_spread - 1.0f) * unison_vibratto_a;
 
         float increments_per_second = synth->samplerate_f / synth->buffersize_f;
-        float vibratto_base_period  = 0.25f
-                                      * powf(
-            2.0f,
-            (1.0f
-             - pars->VoicePar[nvoice].
-             Unison_vibratto_speed
-             / 127.0f) * 4.0f);
+        const float vib_speed = pars.VoicePar[nvoice].Unison_vibratto_speed / 127.0f;
+        float vibratto_base_period  = 0.25f * powf(2.0f, (1.0f - vib_speed) * 4.0f);
         for(int k = 0; k < unison; ++k) {
             unison_vibratto[nvoice].position[k] = RND * 1.8f - 0.9f;
             //make period to vary randomly from 50% to 200% vibratto base period
@@ -195,7 +189,7 @@ ADnote::ADnote(ADnoteParameters *pars, SynthParams &spars)
         //phase invert for unison
         unison_invert_phase[nvoice][0] = false;
         if(unison != 1) {
-            int inv = pars->VoicePar[nvoice].Unison_invert_phase;
+            int inv = pars.VoicePar[nvoice].Unison_invert_phase;
             switch(inv) {
                 case 0: for(int k = 0; k < unison; ++k)
                         unison_invert_phase[nvoice][k] = false;
@@ -221,44 +215,44 @@ ADnote::ADnote(ADnoteParameters *pars, SynthParams &spars)
         oscposloFM[nvoice]  = memory.valloc<float>(unison);
 
         NoteVoicePar[nvoice].Enabled     = ON;
-        NoteVoicePar[nvoice].fixedfreq   = pars->VoicePar[nvoice].Pfixedfreq;
-        NoteVoicePar[nvoice].fixedfreqET = pars->VoicePar[nvoice].PfixedfreqET;
+        NoteVoicePar[nvoice].fixedfreq   = pars.VoicePar[nvoice].Pfixedfreq;
+        NoteVoicePar[nvoice].fixedfreqET = pars.VoicePar[nvoice].PfixedfreqET;
 
         //use the Globalpars.detunetype if the detunetype is 0
-        if(pars->VoicePar[nvoice].PDetuneType != 0) {
+        if(pars.VoicePar[nvoice].PDetuneType != 0) {
             NoteVoicePar[nvoice].Detune = getdetune(
-                pars->VoicePar[nvoice].PDetuneType,
-                pars->VoicePar[nvoice].
+                pars.VoicePar[nvoice].PDetuneType,
+                pars.VoicePar[nvoice].
                 PCoarseDetune,
                 8192); //coarse detune
             NoteVoicePar[nvoice].FineDetune = getdetune(
-                pars->VoicePar[nvoice].PDetuneType,
+                pars.VoicePar[nvoice].PDetuneType,
                 0,
-                pars->VoicePar[nvoice].PDetune); //fine detune
+                pars.VoicePar[nvoice].PDetune); //fine detune
         }
         else {
             NoteVoicePar[nvoice].Detune = getdetune(
-                pars->GlobalPar.PDetuneType,
-                pars->VoicePar[nvoice].
+                pars.GlobalPar.PDetuneType,
+                pars.VoicePar[nvoice].
                 PCoarseDetune,
                 8192); //coarse detune
             NoteVoicePar[nvoice].FineDetune = getdetune(
-                pars->GlobalPar.PDetuneType,
+                pars.GlobalPar.PDetuneType,
                 0,
-                pars->VoicePar[nvoice].PDetune); //fine detune
+                pars.VoicePar[nvoice].PDetune); //fine detune
         }
-        if(pars->VoicePar[nvoice].PFMDetuneType != 0)
+        if(pars.VoicePar[nvoice].PFMDetuneType != 0)
             NoteVoicePar[nvoice].FMDetune = getdetune(
-                pars->VoicePar[nvoice].PFMDetuneType,
-                pars->VoicePar[nvoice].
+                pars.VoicePar[nvoice].PFMDetuneType,
+                pars.VoicePar[nvoice].
                 PFMCoarseDetune,
-                pars->VoicePar[nvoice].PFMDetune);
+                pars.VoicePar[nvoice].PFMDetune);
         else
             NoteVoicePar[nvoice].FMDetune = getdetune(
-                pars->GlobalPar.PDetuneType,
-                pars->VoicePar[nvoice].
+                pars.GlobalPar.PDetuneType,
+                pars.VoicePar[nvoice].
                 PFMCoarseDetune,
-                pars->VoicePar[nvoice].PFMDetune);
+                pars.VoicePar[nvoice].PFMDetune);
 
 
 
@@ -275,14 +269,14 @@ ADnote::ADnote(ADnoteParameters *pars, SynthParams &spars)
 
         //Get the voice's oscil or external's voice oscil
         int vc = nvoice;
-        if(pars->VoicePar[nvoice].Pextoscil != -1)
-            vc = pars->VoicePar[nvoice].Pextoscil;
-        if(!pars->GlobalPar.Hrandgrouping)
-            pars->VoicePar[vc].OscilSmp->newrandseed(prng());
+        if(pars.VoicePar[nvoice].Pextoscil != -1)
+            vc = pars.VoicePar[nvoice].Pextoscil;
+        if(!pars.GlobalPar.Hrandgrouping)
+            pars.VoicePar[vc].OscilSmp->newrandseed(prng());
         int oscposhi_start =
-            pars->VoicePar[vc].OscilSmp->get(NoteVoicePar[nvoice].OscilSmp,
+            pars.VoicePar[vc].OscilSmp->get(NoteVoicePar[nvoice].OscilSmp,
                                              getvoicebasefreq(nvoice),
-                                             pars->VoicePar[nvoice].Presonance);
+                                             pars.VoicePar[nvoice].Presonance);
 
         //I store the first elments to the last position for speedups
         for(int i = 0; i < OSCIL_SMP_EXTRA_SAMPLES; ++i)
@@ -291,7 +285,7 @@ ADnote::ADnote(ADnoteParameters *pars, SynthParams &spars)
                 NoteVoicePar[nvoice].OscilSmp[i];
 
         oscposhi_start +=
-            (int)((pars->VoicePar[nvoice].Poscilphase
+            (int)((pars.VoicePar[nvoice].Poscilphase
                    - 64.0f) / 128.0f * synth->oscilsize + synth->oscilsize * 4);
         oscposhi_start %= synth->oscilsize;
 
@@ -299,7 +293,7 @@ ADnote::ADnote(ADnoteParameters *pars, SynthParams &spars)
             oscposhi[nvoice][k] = oscposhi_start;
             //put random starting point for other subvoices
             oscposhi_start      =
-                (int)(RND * pars->VoicePar[nvoice].Unison_phase_randomness /
+                (int)(RND * pars.VoicePar[nvoice].Unison_phase_randomness /
                         127.0f * (synth->oscilsize - 1));
         }
 
@@ -315,11 +309,11 @@ ADnote::ADnote(ADnoteParameters *pars, SynthParams &spars)
         NoteVoicePar[nvoice].FilterLfo      = NULL;
 
         NoteVoicePar[nvoice].FilterCenterPitch =
-            pars->VoicePar[nvoice].VoiceFilter->getfreq();
+            pars.VoicePar[nvoice].VoiceFilter->getfreq();
         NoteVoicePar[nvoice].filterbypass =
-            pars->VoicePar[nvoice].Pfilterbypass;
+            pars.VoicePar[nvoice].Pfilterbypass;
 
-        switch(pars->VoicePar[nvoice].PFMEnabled) {
+        switch(pars.VoicePar[nvoice].PFMEnabled) {
             case 1:
                 NoteVoicePar[nvoice].FMEnabled = MORPH;
                 break;
@@ -339,44 +333,44 @@ ADnote::ADnote(ADnoteParameters *pars, SynthParams &spars)
                 NoteVoicePar[nvoice].FMEnabled = NONE;
         }
 
-        NoteVoicePar[nvoice].FMVoice = pars->VoicePar[nvoice].PFMVoice;
+        NoteVoicePar[nvoice].FMVoice = pars.VoicePar[nvoice].PFMVoice;
         NoteVoicePar[nvoice].FMFreqEnvelope = NULL;
         NoteVoicePar[nvoice].FMAmpEnvelope  = NULL;
 
         //Compute the Voice's modulator volume (incl. damping)
         float fmvoldamp = powf(440.0f / getvoicebasefreq(
                                    nvoice),
-                               pars->VoicePar[nvoice].PFMVolumeDamp / 64.0f
+                               pars.VoicePar[nvoice].PFMVolumeDamp / 64.0f
                                - 1.0f);
         switch(NoteVoicePar[nvoice].FMEnabled) {
             case PHASE_MOD:
                 fmvoldamp =
                     powf(440.0f / getvoicebasefreq(
-                             nvoice), pars->VoicePar[nvoice].PFMVolumeDamp
+                             nvoice), pars.VoicePar[nvoice].PFMVolumeDamp
                          / 64.0f);
                 NoteVoicePar[nvoice].FMVolume =
-                    (expf(pars->VoicePar[nvoice].PFMVolume / 127.0f
+                    (expf(pars.VoicePar[nvoice].PFMVolume / 127.0f
                           * FM_AMP_MULTIPLIER) - 1.0f) * fmvoldamp * 4.0f;
                 break;
             case FREQ_MOD:
                 NoteVoicePar[nvoice].FMVolume =
-                    (expf(pars->VoicePar[nvoice].PFMVolume / 127.0f
+                    (expf(pars.VoicePar[nvoice].PFMVolume / 127.0f
                           * FM_AMP_MULTIPLIER) - 1.0f) * fmvoldamp * 4.0f;
                 break;
-            //    case PITCH_MOD:NoteVoicePar[nvoice].FMVolume=(pars->VoicePar[nvoice].PFMVolume/127.0f*8.0f)*fmvoldamp;//???????????
+            //    case PITCH_MOD:NoteVoicePar[nvoice].FMVolume=(pars.VoicePar[nvoice].PFMVolume/127.0f*8.0f)*fmvoldamp;//???????????
             //	          break;
             default:
                 if(fmvoldamp > 1.0f)
                     fmvoldamp = 1.0f;
                 NoteVoicePar[nvoice].FMVolume =
-                    pars->VoicePar[nvoice].PFMVolume
+                    pars.VoicePar[nvoice].PFMVolume
                     / 127.0f * fmvoldamp;
         }
 
         //Voice's modulator velocity sensing
         NoteVoicePar[nvoice].FMVolume *=
             VelF(velocity,
-                 partparams->VoicePar[nvoice].PFMVelocityScaleFunction);
+                 pars.VoicePar[nvoice].PFMVelocityScaleFunction);
 
         FMoldsmp[nvoice] = memory.valloc<float>(unison);
         for(int k = 0; k < unison; ++k)
@@ -384,7 +378,7 @@ ADnote::ADnote(ADnoteParameters *pars, SynthParams &spars)
 
         firsttick[nvoice] = 1;
         NoteVoicePar[nvoice].DelayTicks =
-            (int)((expf(pars->VoicePar[nvoice].PDelay / 127.0f
+            (int)((expf(pars.VoicePar[nvoice].PDelay / 127.0f
                         * logf(50.0f))
                    - 1.0f) / synth->buffersize_f / 10.0f * synth->samplerate_f);
     }
@@ -410,7 +404,7 @@ ADnote::ADnote(ADnoteParameters *pars, SynthParams &spars)
 // possible I left stuff that is not required for this.
 void ADnote::legatonote(LegatoParams lpars)
 {
-    ADnoteParameters *pars = partparams;
+    //ADnoteParameters &pars = *partparams;
 
     // Manage legato stuff
     if(legato.update(lpars))
@@ -424,22 +418,22 @@ void ADnote::legatonote(LegatoParams lpars)
         velocity = 1.0f;
     velocity = lpars.velocity;
 
-    NoteGlobalPar.Detune = getdetune(pars->GlobalPar.PDetuneType,
-                                     pars->GlobalPar.PCoarseDetune,
-                                     pars->GlobalPar.PDetune);
-    bandwidthDetuneMultiplier = pars->getBandwidthDetuneMultiplier();
+    NoteGlobalPar.Detune = getdetune(pars.GlobalPar.PDetuneType,
+                                     pars.GlobalPar.PCoarseDetune,
+                                     pars.GlobalPar.PDetune);
+    bandwidthDetuneMultiplier = pars.getBandwidthDetuneMultiplier();
 
-    if(pars->GlobalPar.PPanning == 0)
+    if(pars.GlobalPar.PPanning == 0)
         NoteGlobalPar.Panning = RND;
     else
-        NoteGlobalPar.Panning = pars->GlobalPar.PPanning / 128.0f;
+        NoteGlobalPar.Panning = pars.GlobalPar.PPanning / 128.0f;
 
     //center freq
-    NoteGlobalPar.FilterCenterPitch = pars->GlobalPar.GlobalFilter->getfreq()
-                                      + pars->GlobalPar.PFilterVelocityScale
+    NoteGlobalPar.FilterCenterPitch = pars.GlobalPar.GlobalFilter->getfreq()
+                                      + pars.GlobalPar.PFilterVelocityScale
                                       / 127.0f * 6.0f          //velocity sensing
                                       * (VelF(velocity,
-                                              pars->GlobalPar.
+                                              pars.GlobalPar.
                                               PFilterVelocityScaleFunction) - 1);
 
 
@@ -447,52 +441,52 @@ void ADnote::legatonote(LegatoParams lpars)
         if(NoteVoicePar[nvoice].Enabled == OFF)
             continue;  //(gf) Stay the same as first note in legato.
 
-        NoteVoicePar[nvoice].fixedfreq   = pars->VoicePar[nvoice].Pfixedfreq;
-        NoteVoicePar[nvoice].fixedfreqET = pars->VoicePar[nvoice].PfixedfreqET;
+        NoteVoicePar[nvoice].fixedfreq   = pars.VoicePar[nvoice].Pfixedfreq;
+        NoteVoicePar[nvoice].fixedfreqET = pars.VoicePar[nvoice].PfixedfreqET;
 
         //use the Globalpars.detunetype if the detunetype is 0
-        if(pars->VoicePar[nvoice].PDetuneType != 0) {
+        if(pars.VoicePar[nvoice].PDetuneType != 0) {
             NoteVoicePar[nvoice].Detune = getdetune(
-                pars->VoicePar[nvoice].PDetuneType,
-                pars->VoicePar[nvoice].PCoarseDetune,
+                pars.VoicePar[nvoice].PDetuneType,
+                pars.VoicePar[nvoice].PCoarseDetune,
                 8192); //coarse detune
             NoteVoicePar[nvoice].FineDetune = getdetune(
-                pars->VoicePar[nvoice].PDetuneType,
+                pars.VoicePar[nvoice].PDetuneType,
                 0,
-                pars->VoicePar[nvoice].PDetune); //fine detune
+                pars.VoicePar[nvoice].PDetune); //fine detune
         }
         else {
             NoteVoicePar[nvoice].Detune = getdetune(
-                pars->GlobalPar.PDetuneType,
-                pars->VoicePar[nvoice].PCoarseDetune,
+                pars.GlobalPar.PDetuneType,
+                pars.VoicePar[nvoice].PCoarseDetune,
                 8192); //coarse detune
             NoteVoicePar[nvoice].FineDetune = getdetune(
-                pars->GlobalPar.PDetuneType,
+                pars.GlobalPar.PDetuneType,
                 0,
-                pars->VoicePar[nvoice].PDetune); //fine detune
+                pars.VoicePar[nvoice].PDetune); //fine detune
         }
-        if(pars->VoicePar[nvoice].PFMDetuneType != 0)
+        if(pars.VoicePar[nvoice].PFMDetuneType != 0)
             NoteVoicePar[nvoice].FMDetune = getdetune(
-                pars->VoicePar[nvoice].PFMDetuneType,
-                pars->VoicePar[nvoice].PFMCoarseDetune,
-                pars->VoicePar[nvoice].PFMDetune);
+                pars.VoicePar[nvoice].PFMDetuneType,
+                pars.VoicePar[nvoice].PFMCoarseDetune,
+                pars.VoicePar[nvoice].PFMDetune);
         else
             NoteVoicePar[nvoice].FMDetune = getdetune(
-                pars->GlobalPar.PDetuneType,
-                pars->VoicePar[nvoice].PFMCoarseDetune,
-                pars->VoicePar[nvoice].PFMDetune);
+                pars.GlobalPar.PDetuneType,
+                pars.VoicePar[nvoice].PFMCoarseDetune,
+                pars.VoicePar[nvoice].PFMDetune);
 
 
         //Get the voice's oscil or external's voice oscil
         int vc = nvoice;
-        if(pars->VoicePar[nvoice].Pextoscil != -1)
-            vc = pars->VoicePar[nvoice].Pextoscil;
-        if(!pars->GlobalPar.Hrandgrouping)
-            pars->VoicePar[vc].OscilSmp->newrandseed(prng());
+        if(pars.VoicePar[nvoice].Pextoscil != -1)
+            vc = pars.VoicePar[nvoice].Pextoscil;
+        if(!pars.GlobalPar.Hrandgrouping)
+            pars.VoicePar[vc].OscilSmp->newrandseed(prng());
 
-        pars->VoicePar[vc].OscilSmp->get(NoteVoicePar[nvoice].OscilSmp,
+        pars.VoicePar[vc].OscilSmp->get(NoteVoicePar[nvoice].OscilSmp,
                                          getvoicebasefreq(nvoice),
-                                         pars->VoicePar[nvoice].Presonance); //(gf)Modif of the above line.
+                                         pars.VoicePar[nvoice].Presonance); //(gf)Modif of the above line.
 
         //I store the first elments to the last position for speedups
         for(int i = 0; i < OSCIL_SMP_EXTRA_SAMPLES; ++i)
@@ -502,50 +496,50 @@ void ADnote::legatonote(LegatoParams lpars)
 
 
         NoteVoicePar[nvoice].FilterCenterPitch =
-            pars->VoicePar[nvoice].VoiceFilter->getfreq();
+            pars.VoicePar[nvoice].VoiceFilter->getfreq();
         NoteVoicePar[nvoice].filterbypass =
-            pars->VoicePar[nvoice].Pfilterbypass;
+            pars.VoicePar[nvoice].Pfilterbypass;
 
 
-        NoteVoicePar[nvoice].FMVoice = pars->VoicePar[nvoice].PFMVoice;
+        NoteVoicePar[nvoice].FMVoice = pars.VoicePar[nvoice].PFMVoice;
 
         //Compute the Voice's modulator volume (incl. damping)
         float fmvoldamp = powf(440.0f / getvoicebasefreq(nvoice),
-                               pars->VoicePar[nvoice].PFMVolumeDamp / 64.0f
+                               pars.VoicePar[nvoice].PFMVolumeDamp / 64.0f
                                - 1.0f);
 
         switch(NoteVoicePar[nvoice].FMEnabled) {
             case PHASE_MOD:
                 fmvoldamp =
                     powf(440.0f / getvoicebasefreq(
-                             nvoice), pars->VoicePar[nvoice].PFMVolumeDamp
+                             nvoice), pars.VoicePar[nvoice].PFMVolumeDamp
                          / 64.0f);
                 NoteVoicePar[nvoice].FMVolume =
-                    (expf(pars->VoicePar[nvoice].PFMVolume / 127.0f
+                    (expf(pars.VoicePar[nvoice].PFMVolume / 127.0f
                           * FM_AMP_MULTIPLIER) - 1.0f) * fmvoldamp * 4.0f;
                 break;
             case FREQ_MOD:
                 NoteVoicePar[nvoice].FMVolume =
-                    (expf(pars->VoicePar[nvoice].PFMVolume / 127.0f
+                    (expf(pars.VoicePar[nvoice].PFMVolume / 127.0f
                           * FM_AMP_MULTIPLIER) - 1.0f) * fmvoldamp * 4.0f;
                 break;
-            //    case PITCH_MOD:NoteVoicePar[nvoice].FMVolume=(pars->VoicePar[nvoice].PFMVolume/127.0f*8.0f)*fmvoldamp;//???????????
+            //    case PITCH_MOD:NoteVoicePar[nvoice].FMVolume=(pars.VoicePar[nvoice].PFMVolume/127.0f*8.0f)*fmvoldamp;//???????????
             //	          break;
             default:
                 if(fmvoldamp > 1.0f)
                     fmvoldamp = 1.0f;
                 NoteVoicePar[nvoice].FMVolume =
-                    pars->VoicePar[nvoice].PFMVolume
+                    pars.VoicePar[nvoice].PFMVolume
                     / 127.0f * fmvoldamp;
         }
 
         //Voice's modulator velocity sensing
         NoteVoicePar[nvoice].FMVolume *=
             VelF(velocity,
-                 partparams->VoicePar[nvoice].PFMVelocityScaleFunction);
+                 pars.VoicePar[nvoice].PFMVelocityScaleFunction);
 
         NoteVoicePar[nvoice].DelayTicks =
-            (int)((expf(pars->VoicePar[nvoice].PDelay / 127.0f
+            (int)((expf(pars.VoicePar[nvoice].PDelay / 127.0f
                         * logf(50.0f))
                    - 1.0f) / synth->buffersize_f / 10.0f * synth->samplerate_f);
     }
@@ -559,20 +553,19 @@ void ADnote::legatonote(LegatoParams lpars)
 
     NoteGlobalPar.Volume = 4.0f
                            * powf(0.1f, 3.0f
-                                  * (1.0f - partparams->GlobalPar.PVolume
+                                  * (1.0f - pars.GlobalPar.PVolume
                                      / 96.0f))                                      //-60 dB .. 0 dB
                            * VelF(
         velocity,
-        partparams->GlobalPar.
-        PAmpVelocityScaleFunction);                                                      //velocity sensing
+        pars.GlobalPar.PAmpVelocityScaleFunction); //velocity sensing
 
     globalnewamplitude = NoteGlobalPar.Volume
                          * NoteGlobalPar.AmpEnvelope->envout_dB()
                          * NoteGlobalPar.AmpLfo->amplfoout();
 
-    NoteGlobalPar.FilterQ = partparams->GlobalPar.GlobalFilter->getq();
+    NoteGlobalPar.FilterQ = pars.GlobalPar.GlobalFilter->getq();
     NoteGlobalPar.FilterFreqTracking =
-        partparams->GlobalPar.GlobalFilter->getfreqtracking(basefreq);
+        pars.GlobalPar.GlobalFilter->getfreqtracking(basefreq);
 
     // Forbids the Modulation Voice to be greater or equal than voice
     for(int i = 0; i < NUM_VOICES; ++i)
@@ -584,51 +577,50 @@ void ADnote::legatonote(LegatoParams lpars)
         if(NoteVoicePar[nvoice].Enabled == 0)
             continue;
 
-        NoteVoicePar[nvoice].noisetype = partparams->VoicePar[nvoice].Type;
+        NoteVoicePar[nvoice].noisetype = pars.VoicePar[nvoice].Type;
         /* Voice Amplitude Parameters Init */
         NoteVoicePar[nvoice].Volume =
             powf(0.1f, 3.0f
-                 * (1.0f - partparams->VoicePar[nvoice].PVolume / 127.0f))             // -60 dB .. 0 dB
+                 * (1.0f - pars.VoicePar[nvoice].PVolume / 127.0f))             // -60 dB .. 0 dB
             * VelF(velocity,
-                   partparams->VoicePar[nvoice].PAmpVelocityScaleFunction); //velocity
+                   pars.VoicePar[nvoice].PAmpVelocityScaleFunction); //velocity
 
-        if(partparams->VoicePar[nvoice].PVolumeminus != 0)
+        if(pars.VoicePar[nvoice].PVolumeminus != 0)
             NoteVoicePar[nvoice].Volume = -NoteVoicePar[nvoice].Volume;
 
-        if(partparams->VoicePar[nvoice].PPanning == 0)
+        if(pars.VoicePar[nvoice].PPanning == 0)
             NoteVoicePar[nvoice].Panning = RND;  // random panning
         else
             NoteVoicePar[nvoice].Panning =
-                partparams->VoicePar[nvoice].PPanning / 128.0f;
+                pars.VoicePar[nvoice].PPanning / 128.0f;
 
         newamplitude[nvoice] = 1.0f;
-        if((partparams->VoicePar[nvoice].PAmpEnvelopeEnabled != 0)
-           && (NoteVoicePar[nvoice].AmpEnvelope != NULL))
+        if(pars.VoicePar[nvoice].PAmpEnvelopeEnabled
+           && NoteVoicePar[nvoice].AmpEnvelope)
             newamplitude[nvoice] *= NoteVoicePar[nvoice].AmpEnvelope->envout_dB();
 
 
-        if((partparams->VoicePar[nvoice].PAmpLfoEnabled != 0)
-           && (NoteVoicePar[nvoice].AmpLfo != NULL))
+        if(pars.VoicePar[nvoice].PAmpLfoEnabled && NoteVoicePar[nvoice].AmpLfo)
             newamplitude[nvoice] *= NoteVoicePar[nvoice].AmpLfo->amplfoout();
 
 
 
         NoteVoicePar[nvoice].FilterFreqTracking =
-            partparams->VoicePar[nvoice].VoiceFilter->getfreqtracking(basefreq);
+            pars.VoicePar[nvoice].VoiceFilter->getfreqtracking(basefreq);
 
         /* Voice Modulation Parameters Init */
         if((NoteVoicePar[nvoice].FMEnabled != NONE)
            && (NoteVoicePar[nvoice].FMVoice < 0)) {
-            partparams->VoicePar[nvoice].FMSmp->newrandseed(prng());
+            pars.VoicePar[nvoice].FMSmp->newrandseed(prng());
 
             //Perform Anti-aliasing only on MORPH or RING MODULATION
 
             int vc = nvoice;
-            if(partparams->VoicePar[nvoice].PextFMoscil != -1)
-                vc = partparams->VoicePar[nvoice].PextFMoscil;
+            if(pars.VoicePar[nvoice].PextFMoscil != -1)
+                vc = pars.VoicePar[nvoice].PextFMoscil;
 
-            if(!partparams->GlobalPar.Hrandgrouping)
-                partparams->VoicePar[vc].FMSmp->newrandseed(prng());
+            if(!pars.GlobalPar.Hrandgrouping)
+                pars.VoicePar[vc].FMSmp->newrandseed(prng());
 
             for(int i = 0; i < OSCIL_SMP_EXTRA_SAMPLES; ++i)
                 NoteVoicePar[nvoice].FMSmp[synth->oscilsize + i] =
@@ -636,10 +628,10 @@ void ADnote::legatonote(LegatoParams lpars)
         }
 
         FMnewamplitude[nvoice] = NoteVoicePar[nvoice].FMVolume
-                                 * ctl->fmamp.relamp;
+                                 * ctl.fmamp.relamp;
 
-        if((partparams->VoicePar[nvoice].PFMAmpEnvelopeEnabled != 0)
-           && (NoteVoicePar[nvoice].FMAmpEnvelope != NULL))
+        if(pars.VoicePar[nvoice].PFMAmpEnvelopeEnabled
+           && NoteVoicePar[nvoice].FMAmpEnvelope)
             FMnewamplitude[nvoice] *=
                 NoteVoicePar[nvoice].FMAmpEnvelope->envout_dB();
     }
@@ -716,9 +708,10 @@ ADnote::~ADnote()
 void ADnote::initparameters()
 {
     int tmp[NUM_VOICES];
+    //ADnoteParameters &pars = *partparams;
 
     // Global Parameters
-    NoteGlobalPar.initparameters(partparams->GlobalPar,
+    NoteGlobalPar.initparameters(pars.GlobalPar,
                                  memory, basefreq, velocity,
                                  stereo);
 
@@ -735,7 +728,7 @@ void ADnote::initparameters()
     // Voice Parameter init
     for(int nvoice = 0; nvoice < NUM_VOICES; ++nvoice) {
         Voice &vce = NoteVoicePar[nvoice];
-        ADnoteVoiceParam &param = partparams->VoicePar[nvoice];
+        ADnoteVoiceParam &param = pars.VoicePar[nvoice];
 
         if(vce.Enabled == 0)
             continue;
@@ -799,17 +792,17 @@ void ADnote::initparameters()
                 vc = param.PextFMoscil;
 
             float tmp = 1.0f;
-            if((partparams->VoicePar[vc].FMSmp->Padaptiveharmonics != 0)
+            if((pars.VoicePar[vc].FMSmp->Padaptiveharmonics != 0)
                || (vce.FMEnabled == MORPH)
                || (vce.FMEnabled == RING_MOD))
                 tmp = getFMvoicebasefreq(nvoice);
 
-            if(!partparams->GlobalPar.Hrandgrouping)
-                partparams->VoicePar[vc].FMSmp->newrandseed(prng());
+            if(!pars.GlobalPar.Hrandgrouping)
+                pars.VoicePar[vc].FMSmp->newrandseed(prng());
 
             for(int k = 0; k < unison_size[nvoice]; ++k)
                 oscposhiFM[nvoice][k] = (oscposhi[nvoice][k]
-                                         + partparams->VoicePar[vc].FMSmp->get(
+                                         + pars.VoicePar[vc].FMSmp->get(
                                              vce.FMSmp, tmp))
                                         % synth->oscilsize;
 
@@ -828,7 +821,7 @@ void ADnote::initparameters()
         if(param.PFMFreqEnvelopeEnabled)
             vce.FMFreqEnvelope = memory.alloc<Envelope>(*param.FMFreqEnvelope, basefreq);
 
-        FMnewamplitude[nvoice] = vce.FMVolume * ctl->fmamp.relamp;
+        FMnewamplitude[nvoice] = vce.FMVolume * ctl.fmamp.relamp;
 
         if(param.PFMAmpEnvelopeEnabled ) {
             vce.FMAmpEnvelope =
@@ -862,7 +855,7 @@ void ADnote::compute_unison_freq_rap(int nvoice) {
         unison_freq_rap[nvoice][0] = 1.0f;
         return;
     }
-    float relbw = ctl->bandwidth.relbw * bandwidthDetuneMultiplier;
+    float relbw = ctl.bandwidth.relbw * bandwidthDetuneMultiplier;
     for(int k = 0; k < unison_size[nvoice]; ++k) {
         float pos  = unison_vibratto[nvoice].position[k];
         float step = unison_vibratto[nvoice].step[k];
@@ -927,7 +920,7 @@ float ADnote::getvoicebasefreq(int nvoice) const
 {
     float detune = NoteVoicePar[nvoice].Detune / 100.0f
                    + NoteVoicePar[nvoice].FineDetune / 100.0f
-                   * ctl->bandwidth.relbw * bandwidthDetuneMultiplier
+                   * ctl.bandwidth.relbw * bandwidthDetuneMultiplier
                    + NoteGlobalPar.Detune / 100.0f;
 
     if(NoteVoicePar[nvoice].fixedfreq == 0)
@@ -968,7 +961,7 @@ void ADnote::computecurrentparameters()
           FMrelativepitch, globalpitch, globalfilterpitch;
     globalpitch = 0.01f * (NoteGlobalPar.FreqEnvelope->envout()
                            + NoteGlobalPar.FreqLfo->lfoout()
-                           * ctl->modwheel.relmod);
+                           * ctl.modwheel.relmod);
     globaloldamplitude = globalnewamplitude;
     globalnewamplitude = NoteGlobalPar.Volume
                          * NoteGlobalPar.AmpEnvelope->envout_dB()
@@ -978,12 +971,12 @@ void ADnote::computecurrentparameters()
                         + NoteGlobalPar.FilterLfo->lfoout()
                         + NoteGlobalPar.FilterCenterPitch;
 
-    float tmpfilterfreq = globalfilterpitch + ctl->filtercutoff.relfreq
+    float tmpfilterfreq = globalfilterpitch + ctl.filtercutoff.relfreq
                           + NoteGlobalPar.FilterFreqTracking;
 
     tmpfilterfreq = Filter::getrealfreq(tmpfilterfreq);
 
-    float globalfilterq = NoteGlobalPar.FilterQ * ctl->filterq.relq;
+    float globalfilterq = NoteGlobalPar.FilterQ * ctl.filterq.relq;
     NoteGlobalPar.GlobalFilterL->setfreq_and_q(tmpfilterfreq, globalfilterq);
     if(stereo != 0)
         NoteGlobalPar.GlobalFilterR->setfreq_and_q(tmpfilterfreq, globalfilterq);
@@ -991,8 +984,8 @@ void ADnote::computecurrentparameters()
     //compute the portamento, if it is used by this note
     float portamentofreqrap = 1.0f;
     if(portamento != 0) { //this voice use portamento
-        portamentofreqrap = ctl->portamento.freqrap;
-        if(ctl->portamento.used == 0) //the portamento has finished
+        portamentofreqrap = ctl.portamento.freqrap;
+        if(ctl.portamento.used == 0) //the portamento has finished
             portamento = 0;  //this note is no longer "portamented"
     }
 
@@ -1021,13 +1014,13 @@ void ADnote::computecurrentparameters()
         /****************/
         /* Voice Filter */
         /****************/
-        if(NoteVoicePar[nvoice].VoiceFilterL != NULL) {
+        if(NoteVoicePar[nvoice].VoiceFilterL) {
             filterpitch = NoteVoicePar[nvoice].FilterCenterPitch;
 
-            if(NoteVoicePar[nvoice].FilterEnvelope != NULL)
+            if(NoteVoicePar[nvoice].FilterEnvelope)
                 filterpitch += NoteVoicePar[nvoice].FilterEnvelope->envout();
 
-            if(NoteVoicePar[nvoice].FilterLfo != NULL)
+            if(NoteVoicePar[nvoice].FilterLfo)
                 filterpitch += NoteVoicePar[nvoice].FilterLfo->lfoout();
 
             filterfreq = filterpitch + NoteVoicePar[nvoice].FilterFreqTracking;
@@ -1043,16 +1036,16 @@ void ADnote::computecurrentparameters()
             /* Voice Frequency */
             /*******************/
             voicepitch = 0.0f;
-            if(NoteVoicePar[nvoice].FreqLfo != NULL)
+            if(NoteVoicePar[nvoice].FreqLfo)
                 voicepitch += NoteVoicePar[nvoice].FreqLfo->lfoout() / 100.0f
-                              * ctl->bandwidth.relbw;
+                              * ctl.bandwidth.relbw;
 
-            if(NoteVoicePar[nvoice].FreqEnvelope != NULL)
+            if(NoteVoicePar[nvoice].FreqEnvelope)
                 voicepitch += NoteVoicePar[nvoice].FreqEnvelope->envout()
                               / 100.0f;
             voicefreq = getvoicebasefreq(nvoice)
                         * powf(2, (voicepitch + globalpitch) / 12.0f);                //Hz frequency
-            voicefreq *= ctl->pitchwheel.relfreq; //change the frequency by the controller
+            voicefreq *= ctl.pitchwheel.relfreq; //change the frequency by the controller
             setfreq(nvoice, voicefreq * portamentofreqrap);
 
             /***************/
@@ -1060,7 +1053,7 @@ void ADnote::computecurrentparameters()
             /***************/
             if(NoteVoicePar[nvoice].FMEnabled != NONE) {
                 FMrelativepitch = NoteVoicePar[nvoice].FMDetune / 100.0f;
-                if(NoteVoicePar[nvoice].FMFreqEnvelope != NULL)
+                if(NoteVoicePar[nvoice].FMFreqEnvelope)
                     FMrelativepitch +=
                         NoteVoicePar[nvoice].FMFreqEnvelope->envout() / 100;
                 FMfreq =
@@ -1070,8 +1063,8 @@ void ADnote::computecurrentparameters()
 
                 FMoldamplitude[nvoice] = FMnewamplitude[nvoice];
                 FMnewamplitude[nvoice] = NoteVoicePar[nvoice].FMVolume
-                                         * ctl->fmamp.relamp;
-                if(NoteVoicePar[nvoice].FMAmpEnvelope != NULL)
+                                         * ctl.fmamp.relamp;
+                if(NoteVoicePar[nvoice].FMAmpEnvelope)
                     FMnewamplitude[nvoice] *=
                         NoteVoicePar[nvoice].FMAmpEnvelope->envout_dB();
             }
@@ -1186,8 +1179,6 @@ inline void ADnote::ComputeVoiceOscillator_CubicInterpolation(int nvoice){
  */
 inline void ADnote::ComputeVoiceOscillatorMorph(int nvoice)
 {
-    int   i;
-    float amp;
     ComputeVoiceOscillator_LinearInterpolation(nvoice);
     if(FMnewamplitude[nvoice] > 1.0f)
         FMnewamplitude[nvoice] = 1.0f;
@@ -1199,14 +1190,13 @@ inline void ADnote::ComputeVoiceOscillatorMorph(int nvoice)
         int FMVoice = NoteVoicePar[nvoice].FMVoice;
         for(int k = 0; k < unison_size[nvoice]; ++k) {
             float *tw = tmpwave_unison[k];
-            for(i = 0; i < synth->buffersize; ++i) {
-                amp = INTERPOLATE_AMPLITUDE(FMoldamplitude[nvoice],
+            for(int i = 0; i < synth->buffersize; ++i) {
+                float amp = INTERPOLATE_AMPLITUDE(FMoldamplitude[nvoice],
                                             FMnewamplitude[nvoice],
                                             i,
                                             synth->buffersize);
                 tw[i] = tw[i]
-                        * (1.0f
-                           - amp) + amp * NoteVoicePar[FMVoice].VoiceOut[i];
+                    * (1.0f - amp) + amp * NoteVoicePar[FMVoice].VoiceOut[i];
             }
         }
     }
@@ -1218,8 +1208,8 @@ inline void ADnote::ComputeVoiceOscillatorMorph(int nvoice)
             float  freqloFM = oscfreqloFM[nvoice][k];
             float *tw = tmpwave_unison[k];
 
-            for(i = 0; i < synth->buffersize; ++i) {
-                amp = INTERPOLATE_AMPLITUDE(FMoldamplitude[nvoice],
+            for(int i = 0; i < synth->buffersize; ++i) {
+                float amp = INTERPOLATE_AMPLITUDE(FMoldamplitude[nvoice],
                                             FMnewamplitude[nvoice],
                                             i,
                                             synth->buffersize);
@@ -1244,8 +1234,6 @@ inline void ADnote::ComputeVoiceOscillatorMorph(int nvoice)
  */
 inline void ADnote::ComputeVoiceOscillatorRingModulation(int nvoice)
 {
-    int   i;
-    float amp;
     ComputeVoiceOscillator_LinearInterpolation(nvoice);
     if(FMnewamplitude[nvoice] > 1.0f)
         FMnewamplitude[nvoice] = 1.0f;
@@ -1255,8 +1243,8 @@ inline void ADnote::ComputeVoiceOscillatorRingModulation(int nvoice)
         // if I use VoiceOut[] as modullator
         for(int k = 0; k < unison_size[nvoice]; ++k) {
             float *tw = tmpwave_unison[k];
-            for(i = 0; i < synth->buffersize; ++i) {
-                amp = INTERPOLATE_AMPLITUDE(FMoldamplitude[nvoice],
+            for(int i = 0; i < synth->buffersize; ++i) {
+                float amp = INTERPOLATE_AMPLITUDE(FMoldamplitude[nvoice],
                                             FMnewamplitude[nvoice],
                                             i,
                                             synth->buffersize);
@@ -1272,8 +1260,8 @@ inline void ADnote::ComputeVoiceOscillatorRingModulation(int nvoice)
             float  freqloFM = oscfreqloFM[nvoice][k];
             float *tw = tmpwave_unison[k];
 
-            for(i = 0; i < synth->buffersize; ++i) {
-                amp = INTERPOLATE_AMPLITUDE(FMoldamplitude[nvoice],
+            for(int i = 0; i < synth->buffersize; ++i) {
+                float amp = INTERPOLATE_AMPLITUDE(FMoldamplitude[nvoice],
                                             FMnewamplitude[nvoice],
                                             i,
                                             synth->buffersize);
@@ -1579,14 +1567,14 @@ int ADnote::noteout(float *outl, float *outr)
 
 
         // Filter
-        if(NoteVoicePar[nvoice].VoiceFilterL != NULL)
+        if(NoteVoicePar[nvoice].VoiceFilterL)
             NoteVoicePar[nvoice].VoiceFilterL->filterout(&tmpwavel[0]);
-        if((stereo) && (NoteVoicePar[nvoice].VoiceFilterR != NULL))
+        if(stereo && NoteVoicePar[nvoice].VoiceFilterR)
             NoteVoicePar[nvoice].VoiceFilterR->filterout(&tmpwaver[0]);
 
         //check if the amplitude envelope is finished, if yes, the voice will be fadeout
-        if(NoteVoicePar[nvoice].AmpEnvelope != NULL)
-            if(NoteVoicePar[nvoice].AmpEnvelope->finished() != 0) {
+        if(NoteVoicePar[nvoice].AmpEnvelope)
+            if(NoteVoicePar[nvoice].AmpEnvelope->finished()) {
                 for(int i = 0; i < synth->buffersize; ++i)
                     tmpwavel[i] *= 1.0f - (float)i / synth->buffersize_f;
                 if(stereo)
@@ -1597,7 +1585,7 @@ int ADnote::noteout(float *outl, float *outr)
 
 
         // Put the ADnote samples in VoiceOut (without appling Global volume, because I wish to use this voice as a modullator)
-        if(NoteVoicePar[nvoice].VoiceOut != NULL) {
+        if(NoteVoicePar[nvoice].VoiceOut) {
             if(stereo)
                 for(int i = 0; i < synth->buffersize; ++i)
                     NoteVoicePar[nvoice].VoiceOut[i] = tmpwavel[i]
@@ -1635,8 +1623,8 @@ int ADnote::noteout(float *outl, float *outr)
                     bypassl[i] += tmpwavel[i] * NoteVoicePar[nvoice].Volume;
         }
         // chech if there is necesary to proces the voice longer (if the Amplitude envelope isn't finished)
-        if(NoteVoicePar[nvoice].AmpEnvelope != NULL)
-            if(NoteVoicePar[nvoice].AmpEnvelope->finished() != 0)
+        if(NoteVoicePar[nvoice].AmpEnvelope)
+            if(NoteVoicePar[nvoice].AmpEnvelope->finished())
                 KillVoice(nvoice);
     }
 
@@ -1763,7 +1751,8 @@ void ADnote::Voice::kill(Allocator &memory)
 
     if(VoiceOut)
         memset(VoiceOut, 0, synth->bufferbytes);
-    //do not delete, yet: perhaps is used by another voice
+    //the buffer can't be safely deleted as it may be
+    //an input to another voice
 
     Enabled = OFF;
 }
diff --git a/src/Synth/ADnote.h b/src/Synth/ADnote.h
index d3df78aa..1f225ffd 100644
--- a/src/Synth/ADnote.h
+++ b/src/Synth/ADnote.h
@@ -104,13 +104,12 @@ class ADnote:public SynthNote
 
 
         //GLOBALS
-        ADnoteParameters *partparams;
+        ADnoteParameters &pars;
         unsigned char     stereo; //if the note is stereo (allows note Panning)
         int   midinote;
         float velocity, basefreq;
 
         ONOFFTYPE   NoteEnabled;
-        Controller *ctl;
 
         /*****************************************************************/
         /*                    GLOBAL PARAMETERS                          */
-- 
2.47.0

