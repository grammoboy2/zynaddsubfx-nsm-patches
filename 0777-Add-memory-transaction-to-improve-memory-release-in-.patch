From b692a7431fb12400e075486b9273998e31459e44 Mon Sep 17 00:00:00 2001
From: Olivier Jolly <olivier@pcedev.com>
Date: Mon, 30 Nov 2015 23:37:02 +0100
Subject: [PATCH 0777/1936] Add memory transaction to improve memory release in
 degraded mode

When the RT memory pool is exhausted, there are risks of memory leaks
in constructors which allocates memory dynamically.
This patch introduces a way to limit risks of memory leaks when the
RT memory pool cannot allocate any more memory. The RT memory pool
should normally be automatically expanded before exhaustion happens.
---
 src/Misc/Allocator.cpp | 31 ++++++++++++++++++++++++++++-
 src/Misc/Allocator.h   | 44 ++++++++++++++++++++++++++++++++++++++----
 src/Synth/ADnote.cpp   |  2 ++
 3 files changed, 72 insertions(+), 5 deletions(-)

diff --git a/src/Misc/Allocator.cpp b/src/Misc/Allocator.cpp
index 0ce6c0bc..6f6bf7da 100644
--- a/src/Misc/Allocator.cpp
+++ b/src/Misc/Allocator.cpp
@@ -33,7 +33,7 @@ struct AllocatorImpl
     unsigned long long totalAlloced = 0;
 };
 
-Allocator::Allocator(void)
+Allocator::Allocator(void) : transaction_active()
 {
     impl = new AllocatorImpl;
     size_t default_size = 10*1024*1024;
@@ -124,6 +124,19 @@ typedef struct block_header_t
 static const size_t block_header_free_bit = 1 << 0;
 #endif
 
+void Allocator::beginTransaction() {
+    // TODO: log about unsupported nested transaction when a RT compliant
+    // logging is available and transaction_active == true
+    transaction_active = true;
+    transaction_alloc_index = 0;
+}
+
+void Allocator::endTransaction() {
+    // TODO: log about invalid end of transaction when a RT copmliant logging
+    // is available and transaction_active == false
+    transaction_active = false;
+}
+
 bool Allocator::memFree(void *pool) const
 {
     size_t bh_shift = sizeof(next_t)+sizeof(size_t);
@@ -174,6 +187,22 @@ unsigned long long Allocator::totalAlloced() const
     return impl->totalAlloced;
 }
 
+void Allocator::rollbackTransaction() {
+
+    // if a transaction is active
+    if (transaction_active) {
+
+        // deallocate all allocated memory within this transaction
+        for (size_t temp_idx = 0;
+             temp_idx < transaction_alloc_index; ++temp_idx) {
+            dealloc_mem(transaction_alloc_content[temp_idx]);
+        }
+
+    }
+
+    transaction_active = false;
+}
+
 /*
  * Notes on tlsf internals
  * - TLSF consists of blocks linked by block headers and these form a doubly
diff --git a/src/Misc/Allocator.h b/src/Misc/Allocator.h
index 140b7780..9d1e6c29 100644
--- a/src/Misc/Allocator.h
+++ b/src/Misc/Allocator.h
@@ -16,7 +16,8 @@ class Allocator
         virtual void dealloc_mem(void *memory) = 0;
 
         /**
-         * High level allocator method, which return a pointer to a class or struct
+         * High level allocator method, which return a pointer to a class
+         * or struct
          * allocated with the specialized subclass strategy
          * @param ts argument(s) for the constructor of the type T
          * @return a non null pointer to a new object of type T
@@ -26,13 +27,17 @@ class Allocator
         T *alloc(Ts&&... ts)
         {
             void *data = alloc_mem(sizeof(T));
-            if(!data)
+            if(!data) {
+                rollbackTransaction();
                 throw std::bad_alloc();
+            }
+            append_alloc_to_memory_transaction(data);
             return new (data) T(std::forward<Ts>(ts)...);
         }
 
         /**
-         * High level allocator method, which return a pointer to an array of class or struct
+         * High level allocator method, which return a pointer to an array of
+         * class or struct
          * allocated with the specialized subclass strategy
          * @param len the array length
          * @param ts argument(s) for the constructor of the type T
@@ -43,8 +48,11 @@ class Allocator
         T *valloc(size_t len, Ts&&... ts)
         {
             T *data = (T*)alloc_mem(len*sizeof(T));
-            if(!data)
+            if(!data) {
+                rollbackTransaction();
                 throw std::bad_alloc();
+            }
+            append_alloc_to_memory_transaction(data);
             for(unsigned i=0; i<len; ++i)
                 new ((void*)&data[i]) T(std::forward<Ts>(ts)...);
 
@@ -83,6 +91,9 @@ class Allocator
             }
         }
 
+    void beginTransaction();
+    void endTransaction();
+
     virtual void addMemory(void *, size_t mem_size) = 0;
 
     //Return true if the current pool cannot allocate n chunks of chunk_size
@@ -97,6 +108,31 @@ class Allocator
     unsigned long long totalAlloced() const;
 
     struct AllocatorImpl *impl;
+
+private:
+    const static size_t max_transaction_length = 256;
+
+    void* transaction_alloc_content[max_transaction_length];
+    size_t transaction_alloc_index;
+    bool transaction_active;
+
+    void rollbackTransaction();
+
+    /**
+     * Append memory block to the list of memory blocks allocated during this
+     * transaction
+     * @param new_memory pointer to the memory pointer to freshly allocated
+     */
+    void append_alloc_to_memory_transaction(void *new_memory) {
+        if (transaction_active) {
+            if (transaction_alloc_index < max_transaction_length) {
+                transaction_alloc_content[transaction_alloc_index++] = new_memory;
+            }
+            // TODO add log about transaction too long and memory transaction
+            // safety net being disabled
+        }
+    }
+
 };
 
 //! the allocator for normal use
diff --git a/src/Synth/ADnote.cpp b/src/Synth/ADnote.cpp
index 1d13d294..c3f4694b 100644
--- a/src/Synth/ADnote.cpp
+++ b/src/Synth/ADnote.cpp
@@ -38,6 +38,7 @@
 ADnote::ADnote(ADnoteParameters *pars_, SynthParams &spars)
     :SynthNote(spars), pars(*pars_)
 {
+    memory.beginTransaction();
     tmpwavel = memory.valloc<float>(synth.buffersize);
     tmpwaver = memory.valloc<float>(synth.buffersize);
     bypassl  = memory.valloc<float>(synth.buffersize);
@@ -473,6 +474,7 @@ ADnote::ADnote(ADnoteParameters *pars_, SynthParams &spars)
     }
 
     initparameters();
+    memory.endTransaction();
 }
 
 SynthNote *ADnote::cloneLegato(void)
-- 
2.47.0

